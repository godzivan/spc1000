//
// main.c
//
// Circle - A C++ bare metal environment for Raspberry Pi
// Copyright (C) 2014  R. Stange <rsta2@o2online.de>
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#if 0
#include "kernel.h"
#include <circle/startup.h>

int main (void)
{
	// cannot return here because some destructors used in CKernel are not implemented

	CKernel Kernel;
	if (!Kernel.Initialize ())
	{
		halt ();
		return EXIT_HALT;
	}
	
	TShutdownMode ShutdownMode = Kernel.Run ();

	switch (ShutdownMode)
	{
	case ShutdownReboot:
		reboot ();
		return EXIT_REBOOT;

	case ShutdownHalt:
	default:
		halt ();
		return EXIT_HALT;
	}
}

#endif 
#if 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <circle/timer.h>

CInterruptSystem intr;
CTimer time(&intr);

#include <SDL.h>

#include "kernel/platform.h"
#include "kernel/wiring.h"

#define FONT                    vgafont8
#define BIT_SHIFT               (7 - s_bit_no)

#define CHAR_W                  8
#define CHAR_H                  8

static unsigned char vgafont8[128 * 8]= {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
    0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
    0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
    0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
    0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
    0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
    0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
    0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
    0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
    0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
    0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
    0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
    0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
    0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
    0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
    0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
    0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
    0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
    0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
    0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
    0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
    0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
    0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
    0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
    0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
    0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
    0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
    0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
    0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
    0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
    0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
    0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
    0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
    0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
    0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
    0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
    0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
    0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
    0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
    0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
    0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
    0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
    0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
    0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
    0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
    0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
    0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
    0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
    0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
    0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
    0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
    0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
    0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
    0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
    0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
    0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
    0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
    0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
    0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
    0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
    0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
    0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
    0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
    0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
    0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
    0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
    0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
    0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
    0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
    0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
    0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
    0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
    0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
    0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
    0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
    0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
    0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
    0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
    0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
    0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
    0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
    0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
    0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
    0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
    0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
    0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
    0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
    0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
    0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
    0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
    0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
    0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
    0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
    0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
    0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
    0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
    0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
    0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
    0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
    0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
};

static unsigned char keyNormal_it[] = {
    0x0, 0x0, 0x0, 0x0, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
    'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', '0', '\r', 0x0, '\b', '\t', ' ', '\'', 0x0, 0x0,
    '+', '<', 0x0, 0x0, 0x0, '\\', ',', '.', '-', 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, '/', '*', '-', '+', '\r', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', '0', '.', '<', 0x0, 0x0, '='
};

static unsigned char keyShift_it[] = {
    0x0, 0x0, 0x0, 0x0, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '!', '"',
    0x0, '$', '%', '&', '/', '(', ')', '=', '\r', 0x0, '\b', '\t', ' ', '?', '^', 0x0,
    '*', '>', 0x0, 0x0, 0x0, '|', ';', ':', '_', 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, '/', '*', '-', '+', '\r', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', '0', '.', '>', 0x0, 0x0, '='
};

#if defined(__cplusplus)
extern "C" {
#endif

__attribute__ ((interrupt ("IRQ"))) void interrupt_irq() {
    SDL_Interrupt_Handler();
}

#if defined(__cplusplus)
}
#endif

struct _screen {
    unsigned char c;
    struct {
        unsigned char r;
        unsigned char g;
        unsigned char b;
    } fore;
    struct {
        unsigned char r;
        unsigned char g;
        unsigned char b;
    } back;
};

#define txt_width  40
#define txt_height 25

static int cur_x;
static int cur_y;
static int cursor_visible;
static struct _screen screen[txt_width * txt_height];
static SDL_Rect crect;

void SDL_DrawString(const char *s) {
    char c;

    while (*s) {
        c = *s++;
        if (c == '\r') {
            cur_x = 0;
        }
        else if (c == '\n') {
            cur_y++;
            if (cur_y >= txt_height) {
                memcpy(&screen[0], &screen[txt_width], sizeof(screen) - sizeof(struct _screen) * txt_width);
                for (int i = txt_width * (txt_height - 1); i < txt_width * txt_height; i++) {
                    screen[i].c = ' ';
                    screen[i].fore.r = 255;
                    screen[i].fore.g = 255;
                    screen[i].fore.b = 255;
                    screen[i].back.r = 98;
                    screen[i].back.g = 0;
                    screen[i].back.b = 32;
                }
                cur_y--;
            }
        }
        else {
            screen[cur_y * txt_width + cur_x].c = c;
            cur_x++;
            if (cur_x >= txt_width) {
                cur_x = 0;
                cur_y++;
                if (cur_y >= txt_height) {
                    memcpy(&screen[0], &screen[txt_width], sizeof(screen) - sizeof(struct _screen) * txt_width);
                    for (int i = txt_width * (txt_height - 1); i < txt_width * txt_height; i++) {
                        screen[i].c = ' ';
                        screen[i].fore.r = 255;
                        screen[i].fore.g = 255;
                        screen[i].fore.b = 255;
                        screen[i].back.r = 98;
                        screen[i].back.g = 0;
                        screen[i].back.b = 32;
                    }
                    cur_y--;
                }
            }
        }
    }
    cursor_visible = 1;
}

void SDL_DrawStringAt(int y, int x, const char *s) {
    cur_x = x % txt_width;
    cur_y = y % txt_height;
    SDL_DrawString(s);
}

void SDL_DrawChar(char c) {
    if (c == '\r') {
        cur_x = 0;
    }
    else if (c == '\n') {
        cur_y++;
        if (cur_y >= txt_height) {
            memcpy(&screen[0], &screen[txt_width], sizeof(screen) - sizeof(struct _screen) * txt_width);
            for (int i = txt_width * (txt_height - 1); i < txt_width * txt_height; i++) {
                screen[i].c = ' ';
                screen[i].fore.r = 255;
                screen[i].fore.g = 255;
                screen[i].fore.b = 255;
                screen[i].back.r = 98;
                screen[i].back.g = 0;
                screen[i].back.b = 32;
            }
            cur_y--;
        }
    }
    else {
        screen[cur_y * txt_width + cur_x].c = c;
        cur_x++;
        if (cur_x >= txt_width) {
            cur_x = 0;
            cur_y++;
            if (cur_y >= txt_height) {
                memcpy(&screen[0], &screen[txt_width], sizeof(screen) - sizeof(struct _screen) * txt_width);
                for (int i = txt_width * (txt_height - 1); i < txt_width * txt_height; i++) {
                    screen[i].c = ' ';
                    screen[i].fore.r = 255;
                    screen[i].fore.g = 255;
                    screen[i].fore.b = 255;
                    screen[i].back.r = 98;
                    screen[i].back.g = 0;
                    screen[i].back.b = 32;
                }
                cur_y--;
            }
        }
    }
    cursor_visible = 1;
}

void SDL_DrawCharAt(int y, int x, char c) {
    cur_x = x % txt_width;
    cur_y = y % txt_height;
    SDL_DrawChar(c);
}

void SDL_InitConsole(int w, int h) {
    crect.x = (w - txt_width * CHAR_W) / 2;
    crect.y = (h - txt_height * CHAR_H) / 2;
    crect.w = txt_width * CHAR_W;
    crect.h = txt_height * CHAR_H;

    for (int i = 0; i < txt_width * txt_height; i++) {
        screen[i].c = ' ';
        screen[i].fore.r = 255;
        screen[i].fore.g = 255;
        screen[i].fore.b = 255;
        screen[i].back.r = 98;
        screen[i].back.g = 0;
        screen[i].back.b = 32;
    }

    cur_x = 0;
    cur_y = 0;
}

void SDL_RenderConsole(SDL_Renderer *renderer) {
    int x, y, c_x;
    int index = 0;

    for (y = crect.y; index < txt_width * txt_height; y += CHAR_H) {
        for (c_x = 0, x = crect.x; c_x < txt_width && index < txt_width * txt_height; index++, c_x++, x += CHAR_W) {
            int s_offset = (int) screen[index].c * CHAR_W * CHAR_H;
            for (int f_y = 0; f_y < CHAR_H; f_y++) {
                for (int f_x = 0; f_x < CHAR_W; f_x++) {
                    int s_byte_no = s_offset / 8;
                    int s_bit_no = s_offset % 8;

                    unsigned char s_byte = FONT[s_byte_no];
                    if ((s_byte >> BIT_SHIFT) & 0x1)
                        SDL_SetRenderDrawColor(renderer, screen[index].fore.r, screen[index].fore.g, screen[index].fore.b, 255);
                    else
                        SDL_SetRenderDrawColor(renderer, screen[index].back.r, screen[index].back.g, screen[index].back.b, 255);
                    SDL_RenderDrawPoint(renderer, x + f_x, y + f_y);
                    s_offset++;
                }
            }
        }
    }

    if (cursor_visible) {
        SDL_Rect rect;
        rect.x = crect.x + cur_x * CHAR_W;
        rect.y = crect.y + cur_y * CHAR_H;
        rect.w = CHAR_W;
        rect.h = CHAR_H;
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &rect);
    }
}

void main() {
    int w, h;
    SDL_Window *screen;
    SDL_Renderer *renderer;
    SDL_Event event;
    // struct timer_wait tw;
    // int led_status = LOW;


    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_EVENTS);

    // Default screen resolution (set in config.txt or auto-detected)
    //SDL_CreateWindowAndRenderer(0, 0, SDL_WINDOW_FULLSCREEN_DESKTOP, &screen, &renderer);

    // Sets a specific screen resolution
    SDL_CreateWindowAndRenderer(32 + 320 + 32, 32 + 200 + 32, SDL_WINDOW_FULLSCREEN, &screen, &renderer);

    SDL_GetWindowSize(screen, &w, &h);
    SDL_InitConsole(w, h);

    SDL_DrawStringAt(1, (txt_width - 22) / 2, "**** RASPBERRY-PI ****");
    SDL_DrawStringAt(3, (txt_width - 30) / 2, "BARE-METAL SDL SYSTEM TEMPLATE\r\n");

    // pinMode(16, OUTPUT);
    // register_timer(&tw, 250000);

    SDL_DrawString("\r\nREADY\r\n");

    while(1) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_KEYDOWN) {
                switch(event.key.keysym.scancode) {
                    case SDL_SCANCODE_UP:
                        if (cur_y > 0)
                            cur_y--;
                        break;
                    case SDL_SCANCODE_DOWN:
                        if (cur_y < txt_height - 1)
                            cur_y++;
                        break;
                    case SDL_SCANCODE_LEFT:
                        if (cur_x > 0)
                            cur_x--;
                        else if (cur_y > 0) {
                            cur_y--;
                            cur_x = txt_width - 1;
                        }
                        break;
                    case SDL_SCANCODE_RIGHT:
                        if (cur_x < txt_width - 1)
                            cur_x++;
                        else if (cur_y < txt_height - 1) {
                            cur_y++;
                            cur_x = 0;
                        }
                        break;
                    case SDL_SCANCODE_HOME:
                        cur_x = 0;
                        break;
                    case SDL_SCANCODE_END:
                        cur_x = txt_width - 1;
                        break;
                    case SDL_SCANCODE_RETURN:
                        SDL_DrawString("\r\n");
                        break;
                    default: {
                        SDL_Keymod mod = SDL_GetModState();
                        if ((mod & (KMOD_LSHIFT | KMOD_RSHIFT)) != 0) {
                            char c = keyShift_it[event.key.keysym.scancode];
                            if (c >= ' ')
                                SDL_DrawChar(c);
                        }
                        else {
                            char c = keyNormal_it[event.key.keysym.scancode];
                            if (c >= ' ')
                                SDL_DrawChar(c);
                        }
                    }
                }
            }
        }

        // if (compare_timer(&tw)) {
        //     led_status = led_status == LOW ? HIGH : LOW;
        //     digitalWrite(16, led_status);
        //     cursor_visible = cursor_visible ? 0 : 1;
        // }

        SDL_SetRenderDrawColor(renderer, 213, 41, 82, 255);
        SDL_RenderClear(renderer);

        SDL_RenderConsole(renderer);

        SDL_RenderPresent(renderer);
    }
}


#include <circle/timer.h>

extern CTimer time; 

extern "C"
{
int usleep(useconds_t ms) {
    time.MsDelay(ms);
	return 0;
}
}

#endif
