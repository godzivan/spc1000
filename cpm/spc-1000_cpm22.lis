                  ;**************************************************************
                  ;*
                  ;*             C P / M   version   2 . 2
                  ;*
                  ;*   Reconstructed from memory image on February 27, 1981
                  ;*
                  ;*                by Clark A. Calkins
                  ;*
                  ;**************************************************************
                  ;
                  ;   Set memory limit here. This is the amount of contigeous
                  ; ram starting from 0000. CP/M will reside at the end of this space.
                  ;
MEM EQU 58                              ;003a              ;for a 62k system (TS802 TEST - WORKS OK).
                  ;
IOBYTE  EQU 3                           ;0003              ;i/o definition byte.
TDRIVE  EQU 4                           ;0004              ;current drive name and user number.
ENTRY   EQU 5                           ;0005              ;entry point for the cp/m bdos.
TFCB    EQU 5CH                         ;005c              ;default file control block.
TBUFF   EQU 80H                         ;0080              ;i/o buffer and command line storage.
TBASE   EQU 100H                        ;0100              ;transiant program storage area.
                  ;
                  ;   Set control character equates.
                  ;
CNTRLC  EQU 3                           ;0003              ;control-c
CNTRLE  EQU 05H                         ;0005              ;control-e
BS  EQU 08H                             ;0008              ;backspace
TAB EQU 09H                             ;0009              ;tab
LF  EQU 0AH                             ;000a              ;line feed
FF  EQU 0CH                             ;000c              ;form feed
CR  EQU 0DH                             ;000d              ;carriage return
CNTRLP  EQU 10H                         ;0010              ;control-p
CNTRLR  EQU 12H                         ;0012              ;control-r
CNTRLS  EQU 13H                         ;0013              ;control-s
CNTRLU  EQU 15H                         ;0015              ;control-u
CNTRLX  EQU 18H                         ;0018              ;control-x
CNTRLZ  EQU 1AH                         ;001a              ;control-z (end-of-file mark)
DEL EQU 7FH                             ;007f              ;rubout
                  ;
                  ;   Set origin for CP/M
                  ;
    ORG (MEM-7)*1024                    ;                  
                  ;
CBASE:  JP  COMMAND                     ;cc00  c3 5c cf    ;execute command processor (ccp).
    JP  CLEARBUF                        ;cc03  c3 58 cf    ;entry to empty input buffer before starting ccp.
                  
                  ;
                  ;   Standard cp/m ccp input buffer. Format is (max length),
                  ; (actual length), (char #1), (char #2), (char #3), etc.
                  ;
INBUFF: DEFB    127                     ;cc06  7f          ;length of input buffer.
    DEFB    0                           ;cc07  00          ;current length of contents.
    DEFB    'Copyright'                 ;cc08  43 6f 70 79 
                                        ;cc0c  72 69 67 68     53     54
                                        ;cc10  74              53     55
    DEFB    ' 1979 (c) by Digital Research      ';cc11  20 31 39 37 
                                        ;cc15  39 20 28 63     54     57
                                        ;cc19  29 20 62 79     54     58
                                        ;cc1d  20 44 69 67     54     59
                                        ;cc21  69 74 61 6c     54     60
                                        ;cc25  20 52 65 73     54     61
                                        ;cc29  65 61 72 63     54     62
                                        ;cc2d  68 20 20 20     54     63
                                        ;cc31  20 20 20        54     64
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;cc34  00 00 00 00 
                                        ;cc38  00 00 00 00     55     66
                                        ;cc3c  00 00 00 00     55     67
                                        ;cc40  00 00 00 00     55     68
                                        ;cc44  00 00 00 00     55     69
                                        ;cc48  00 00 00        55     70
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;cc4b  00 00 00 00 
                                        ;cc4f  00 00 00 00     56     72
                                        ;cc53  00 00 00 00     56     73
                                        ;cc57  00 00 00 00     56     74
                                        ;cc5b  00 00 00 00     56     75
                                        ;cc5f  00 00 00        56     76
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;cc62  00 00 00 00 
                                        ;cc66  00 00 00 00     57     78
                                        ;cc6a  00 00 00 00     57     79
                                        ;cc6e  00 00 00 00     57     80
                                        ;cc72  00 00 00 00     57     81
                                        ;cc76  00 00 00        57     82
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;cc79  00 00 00 00 
                                        ;cc7d  00 00 00 00     58     84
                                        ;cc81  00 00 00 00     58     85
                                        ;cc85  00 00 00        58     86
INPOINT:DEFW    INBUFF+2                ;cc88  08 cc       ;input line pointer
NAMEPNT:DEFW    0                       ;cc8a  00 00       ;input line pointer used for error message. Points to
                  ;			;start of name in error.
                  ;
                  ;   Routine to print (A) on the console. All registers used.
                  ;
PRINT:  LD  E,A                         ;cc8c  5f          ;setup bdos call.
    LD  C,2                             ;cc8d  0e 02       
    JP  ENTRY                           ;cc8f  c3 05 00    
                  ;
                  ;   Routine to print (A) on the console and to save (BC).
                  ;
PRINTB: PUSH    BC                      ;cc92  c5          
    CALL    PRINT                       ;cc93  cd 8c cc    
    POP BC                              ;cc96  c1          
    RET                                 ;cc97  c9          
                  ;
                  ;   Routine to send a carriage return, line feed combination
                  ; to the console.
                  ;
CRLF:   LD  A,CR                        ;cc98  3e 0d       
    CALL    PRINTB                      ;cc9a  cd 92 cc    
    LD  A,LF                            ;cc9d  3e 0a       
    JP  PRINTB                          ;cc9f  c3 92 cc    
                  ;
                  ;   Routine to send one space to the console and save (BC).
                  ;
SPACE:  LD  A,' '                       ;cca2  3e 20       
    JP  PRINTB                          ;cca4  c3 92 cc    
                  ;
                  ;   Routine to print character string pointed to be (BC) on the
                  ; console. It must terminate with a null byte.
                  ;
PLINE:  PUSH    BC                      ;cca7  c5          
    CALL    CRLF                        ;cca8  cd 98 cc    
    POP HL                              ;ccab  e1          
PLINE2: LD  A,(HL)                      ;ccac  7e          
    OR  A                               ;ccad  b7          
    RET Z                               ;ccae  c8          
    INC HL                              ;ccaf  23          
    PUSH    HL                          ;ccb0  e5          
    CALL    PRINT                       ;ccb1  cd 8c cc    
    POP HL                              ;ccb4  e1          
    JP  PLINE2                          ;ccb5  c3 ac cc    
                  ;
                  ;   Routine to reset the disk system.
                  ;
RESDSK: LD  C,13                        ;ccb8  0e 0d       
    JP  ENTRY                           ;ccba  c3 05 00    
                  ;
                  ;   Routine to select disk (A).
                  ;
DSKSEL: LD  E,A                         ;ccbd  5f          
    LD  C,14                            ;ccbe  0e 0e       
    JP  ENTRY                           ;ccc0  c3 05 00    
                  ;
                  ;   Routine to call bdos and save the return code. The zero
                  ; flag is set on a return of 0ffh.
                  ;
ENTRY1: CALL    ENTRY                   ;ccc3  cd 05 00    
    LD  (RTNCODE),A                     ;ccc6  32 ee d3    ;save return code.
    INC A                               ;ccc9  3c          ;set zero if 0ffh returned.
    RET                                 ;ccca  c9          
                  ;
                  ;   Routine to open a file. (DE) must point to the FCB.
                  ;
OPEN:   LD  C,15                        ;cccb  0e 0f       
    JP  ENTRY1                          ;cccd  c3 c3 cc    
                  ;
                  ;   Routine to open file at (FCB).
                  ;
OPENFCB:XOR A                           ;ccd0  af          ;clear the record number byte at fcb+32
    LD  (FCB+32),A                      ;ccd1  32 ed d3    
    LD  DE,FCB                          ;ccd4  11 cd d3    
    JP  OPEN                            ;ccd7  c3 cb cc    
                  ;
                  ;   Routine to close a file. (DE) points to FCB.
                  ;
CLOSE:  LD  C,16                        ;ccda  0e 10       
    JP  ENTRY1                          ;ccdc  c3 c3 cc    
                  ;
                  ;   Routine to search for the first file with ambigueous name
                  ; (DE).
                  ;
SRCHFST:LD  C,17                        ;ccdf  0e 11       
    JP  ENTRY1                          ;cce1  c3 c3 cc    
                  ;
                  ;   Search for the next ambigeous file name.
                  ;
SRCHNXT:LD  C,18                        ;cce4  0e 12       
    JP  ENTRY1                          ;cce6  c3 c3 cc    
                  ;
                  ;   Search for file at (FCB).
                  ;
SRCHFCB:LD  DE,FCB                      ;cce9  11 cd d3    
    JP  SRCHFST                         ;ccec  c3 df cc    
                  ;
                  ;   Routine to delete a file pointed to by (DE).
                  ;
DELETE: LD  C,19                        ;ccef  0e 13       
    JP  ENTRY                           ;ccf1  c3 05 00    
                  ;
                  ;   Routine to call the bdos and set the zero flag if a zero
                  ; status is returned.
                  ;
ENTRY2: CALL    ENTRY                   ;ccf4  cd 05 00    
    OR  A                               ;ccf7  b7          ;set zero flag if appropriate.
    RET                                 ;ccf8  c9          
                  ;
                  ;   Routine to read the next record from a sequential file.
                  ; (DE) points to the FCB.
                  ;
RDREC:  LD  C,20                        ;ccf9  0e 14       
    JP  ENTRY2                          ;ccfb  c3 f4 cc    
                  ;
                  ;   Routine to read file at (FCB).
                  ;
READFCB:LD  DE,FCB                      ;ccfe  11 cd d3    
    JP  RDREC                           ;cd01  c3 f9 cc    
                  ;
                  ;   Routine to write the next record of a sequential file.
                  ; (DE) points to the FCB.
                  ;
WRTREC: LD  C,21                        ;cd04  0e 15       
    JP  ENTRY2                          ;cd06  c3 f4 cc    
                  ;
                  ;   Routine to create the file pointed to by (DE).
                  ;
CREATE: LD  C,22                        ;cd09  0e 16       
    JP  ENTRY1                          ;cd0b  c3 c3 cc    
                  ;
                  ;   Routine to rename the file pointed to by (DE). Note that
                  ; the new name starts at (DE+16).
                  ;
RENAM:  LD  C,23                        ;cd0e  0e 17       
    JP  ENTRY                           ;cd10  c3 05 00    
                  ;
                  ;   Get the current user code.
                  ;
GETUSR: LD  E,0FFH                      ;cd13  1e ff       
                  ;
                  ;   Routne to get or set the current user code.
                  ; If (E) is FF then this is a GET, else it is a SET.
                  ;
GETSETUC: LD    C,32                    ;cd15  0e 20       
    JP  ENTRY                           ;cd17  c3 05 00    
                  ;
                  ;   Routine to set the current drive byte at (TDRIVE).
                  ;
SETCDRV:CALL    GETUSR                  ;cd1a  cd 13 cd    ;get user number
    ADD A,A                             ;cd1d  87          ;and shift into the upper 4 bits.
    ADD A,A                             ;cd1e  87          
    ADD A,A                             ;cd1f  87          
    ADD A,A                             ;cd20  87          
    LD  HL,CDRIVE                       ;cd21  21 ef d3    ;now add in the current drive number.
    OR  (HL)                            ;cd24  b6          
    LD  (TDRIVE),A                      ;cd25  32 04 00    ;and save.
    RET                                 ;cd28  c9          
                  ;
                  ;   Move currently active drive down to (TDRIVE).
                  ;
MOVECD: LD  A,(CDRIVE)                  ;cd29  3a ef d3    
    LD  (TDRIVE),A                      ;cd2c  32 04 00    
    RET                                 ;cd2f  c9          
                  ;
                  ;   Routine to convert (A) into upper case ascii. Only letters
                  ; are affected.
                  ;
UPPER:  CP  'a'                         ;cd30  fe 61       ;check for letters in the range of 'a' to 'z'.
    RET C                               ;cd32  d8          
    CP  '{'                             ;cd33  fe 7b       
    RET NC                              ;cd35  d0          
    AND 5FH                             ;cd36  e6 5f       ;convert it if found.
    RET                                 ;cd38  c9          
                  ;
                  ;   Routine to get a line of input. We must check to see if the
                  ; user is in (BATCH) mode. If so, then read the input from file
                  ; ($$$.SUB). At the end, reset to console input.
                  ;
GETINP: LD  A,(BATCH)                   ;cd39  3a ab d3    ;if =0, then use console input.
    OR  A                               ;cd3c  b7          
    JP  Z,GETINP1                       ;cd3d  ca 96 cd    
                  ;
                  ;   Use the submit file ($$$.sub) which is prepared by a
                  ; SUBMIT run. It must be on drive (A) and it will be deleted
                  ; if and error occures (like eof).
                  ;
    LD  A,(CDRIVE)                      ;cd40  3a ef d3    ;select drive 0 if need be.
    OR  A                               ;cd43  b7          
    LD  A,0                             ;cd44  3e 00       ;always use drive A for submit.
    CALL    NZ,DSKSEL                   ;cd46  c4 bd cc    ;select it if required.
    LD  DE,BATCHFCB                     ;cd49  11 ac d3    
    CALL    OPEN                        ;cd4c  cd cb cc    ;look for it.
    JP  Z,GETINP1                       ;cd4f  ca 96 cd    ;if not there, use normal input.
    LD  A,(BATCHFCB+15)                 ;cd52  3a bb d3    ;get last record number+1.
    DEC A                               ;cd55  3d          
    LD  (BATCHFCB+32),A                 ;cd56  32 cc d3    
    LD  DE,BATCHFCB                     ;cd59  11 ac d3    
    CALL    RDREC                       ;cd5c  cd f9 cc    ;read last record.
    JP  NZ,GETINP1                      ;cd5f  c2 96 cd    ;quit on end of file.
                  ;
                  ;   Move this record into input buffer.
                  ;
    LD  DE,INBUFF+1                     ;cd62  11 07 cc    
    LD  HL,TBUFF                        ;cd65  21 80 00    ;data was read into buffer here.
    LD  B,128                           ;cd68  06 80       ;all 128 characters may be used.
    CALL    HL2DE                       ;cd6a  cd 42 d0    ;(HL) to (DE), (B) bytes.
    LD  HL,BATCHFCB+14                  ;cd6d  21 ba d3    
    LD  (HL),0                          ;cd70  36 00       ;zero out the 's2' byte.
    INC HL                              ;cd72  23          ;and decrement the record count.
    DEC (HL)                            ;cd73  35          
    LD  DE,BATCHFCB                     ;cd74  11 ac d3    ;close the batch file now.
    CALL    CLOSE                       ;cd77  cd da cc    
    JP  Z,GETINP1                       ;cd7a  ca 96 cd    ;quit on an error.
    LD  A,(CDRIVE)                      ;cd7d  3a ef d3    ;re-select previous drive if need be.
    OR  A                               ;cd80  b7          
    CALL    NZ,DSKSEL                   ;cd81  c4 bd cc    ;don't do needless selects.
                  ;
                  ;   Print line just read on console.
                  ;
    LD  HL,INBUFF+2                     ;cd84  21 08 cc    
    CALL    PLINE2                      ;cd87  cd ac cc    
    CALL    CHKCON                      ;cd8a  cd c2 cd    ;check console, quit on a key.
    JP  Z,GETINP2                       ;cd8d  ca a7 cd    ;jump if no key is pressed.
                  ;
                  ;   Terminate the submit job on any keyboard input. Delete this
                  ; file such that it is not re-started and jump to normal keyboard
                  ; input section.
                  ;
    CALL    DELBATCH                    ;cd90  cd dd cd    ;delete the batch file.
    JP  CMMND1                          ;cd93  c3 82 cf    ;and restart command input.
                  ;
                  ;   Get here for normal keyboard input. Delete the submit file
                  ; incase there was one.
                  ;
GETINP1:CALL    DELBATCH                ;cd96  cd dd cd    ;delete file ($$$.sub).
    CALL    SETCDRV                     ;cd99  cd 1a cd    ;reset active disk.
    LD  C,10                            ;cd9c  0e 0a       ;get line from console device.
    LD  DE,INBUFF                       ;cd9e  11 06 cc    
    CALL    ENTRY                       ;cda1  cd 05 00    
    CALL    MOVECD                      ;cda4  cd 29 cd    ;reset current drive (again).
                  ;
                  ;   Convert input line to upper case.
                  ;
GETINP2:LD  HL,INBUFF+1                 ;cda7  21 07 cc    
    LD  B,(HL)                          ;cdaa  46          ;(B)=character counter.
GETINP3:INC HL                          ;cdab  23          
    LD  A,B                             ;cdac  78          ;end of the line?
    OR  A                               ;cdad  b7          
    JP  Z,GETINP4                       ;cdae  ca ba cd    
    LD  A,(HL)                          ;cdb1  7e          ;convert to upper case.
    CALL    UPPER                       ;cdb2  cd 30 cd    
    LD  (HL),A                          ;cdb5  77          
    DEC B                               ;cdb6  05          ;adjust character count.
    JP  GETINP3                         ;cdb7  c3 ab cd    
GETINP4:LD  (HL),A                      ;cdba  77          ;add trailing null.
    LD  HL,INBUFF+2                     ;cdbb  21 08 cc    
    LD  (INPOINT),HL                    ;cdbe  22 88 cc    ;reset input line pointer.
    RET                                 ;cdc1  c9          
                  ;
                  ;   Routine to check the console for a key pressed. The zero
                  ; flag is set is none, else the character is returned in (A).
                  ;
CHKCON: LD  C,11                        ;cdc2  0e 0b       ;check console.
    CALL    ENTRY                       ;cdc4  cd 05 00    
    OR  A                               ;cdc7  b7          
    RET Z                               ;cdc8  c8          ;return if nothing.
    LD  C,1                             ;cdc9  0e 01       ;else get character.
    CALL    ENTRY                       ;cdcb  cd 05 00    
    OR  A                               ;cdce  b7          ;clear zero flag and return.
    RET                                 ;cdcf  c9          
                  ;
                  ;   Routine to get the currently active drive number.
                  ;
GETDSK: LD  C,25                        ;cdd0  0e 19       
    JP  ENTRY                           ;cdd2  c3 05 00    
                  ;
                  ;   Set the stabdard dma address.
                  ;
STDDMA: LD  DE,TBUFF                    ;cdd5  11 80 00    
                  ;
                  ;   Routine to set the dma address to (DE).
                  ;
DMASET: LD  C,26                        ;cdd8  0e 1a       
    JP  ENTRY                           ;cdda  c3 05 00    
                  ;
                  ;  Delete the batch file created by SUBMIT.
                  ;
DELBATCH: LD    HL,BATCH                ;cddd  21 ab d3    ;is batch active?
    LD  A,(HL)                          ;cde0  7e          
    OR  A                               ;cde1  b7          
    RET Z                               ;cde2  c8          
    LD  (HL),0                          ;cde3  36 00       ;yes, de-activate it.
    XOR A                               ;cde5  af          
    CALL    DSKSEL                      ;cde6  cd bd cc    ;select drive 0 for sure.
    LD  DE,BATCHFCB                     ;cde9  11 ac d3    ;and delete this file.
    CALL    DELETE                      ;cdec  cd ef cc    
    LD  A,(CDRIVE)                      ;cdef  3a ef d3    ;reset current drive.
    JP  DSKSEL                          ;cdf2  c3 bd cc    
                  ;
                  ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
                  ; the same or we halt....
                  ;
VERIFY: LD  DE,PATTRN1                  ;cdf5  11 28 cf    ;these are the serial number bytes.
    LD  HL,PATTRN2                      ;cdf8  21 00 d4    ;ditto, but how could they be different?
    LD  B,6                             ;cdfb  06 06       ;6 bytes each.
VERIFY1:LD  A,(DE)                      ;cdfd  1a          
    CP  (HL)                            ;cdfe  be          
    JP  NZ,HALT                         ;cdff  c2 cf cf    ;jump to halt routine.
    INC DE                              ;ce02  13          
    INC HL                              ;ce03  23          
    DEC B                               ;ce04  05          
    JP  NZ,VERIFY1                      ;ce05  c2 fd cd    
    RET                                 ;ce08  c9          
                  ;
                  ;   Print back file name with a '?' to indicate a syntax error.
                  ;
SYNERR: CALL    CRLF                    ;ce09  cd 98 cc    ;end current line.
    LD  HL,(NAMEPNT)                    ;ce0c  2a 8a cc    ;this points to name in error.
SYNERR1:LD  A,(HL)                      ;ce0f  7e          ;print it until a space or null is found.
    CP  ' '                             ;ce10  fe 20       
    JP  Z,SYNERR2                       ;ce12  ca 22 ce    
    OR  A                               ;ce15  b7          
    JP  Z,SYNERR2                       ;ce16  ca 22 ce    
    PUSH    HL                          ;ce19  e5          
    CALL    PRINT                       ;ce1a  cd 8c cc    
    POP HL                              ;ce1d  e1          
    INC HL                              ;ce1e  23          
    JP  SYNERR1                         ;ce1f  c3 0f ce    
SYNERR2:LD  A,'?'                       ;ce22  3e 3f       ;add trailing '?'.
    CALL    PRINT                       ;ce24  cd 8c cc    
    CALL    CRLF                        ;ce27  cd 98 cc    
    CALL    DELBATCH                    ;ce2a  cd dd cd    ;delete any batch file.
    JP  CMMND1                          ;ce2d  c3 82 cf    ;and restart from console input.
                  ;
                  ;   Check character at (DE) for legal command input. Note that the
                  ; zero flag is set if the character is a delimiter.
                  ;
CHECK:  LD  A,(DE)                      ;ce30  1a          
    OR  A                               ;ce31  b7          
    RET Z                               ;ce32  c8          
    CP  ' '                             ;ce33  fe 20       ;control characters are not legal here.
    JP  C,SYNERR                        ;ce35  da 09 ce    
    RET Z                               ;ce38  c8          ;check for valid delimiter.
    CP  '='                             ;ce39  fe 3d       
    RET Z                               ;ce3b  c8          
    CP  '_'                             ;ce3c  fe 5f       
    RET Z                               ;ce3e  c8          
    CP  '.'                             ;ce3f  fe 2e       
    RET Z                               ;ce41  c8          
    CP  ':'                             ;ce42  fe 3a       
    RET Z                               ;ce44  c8          
    CP  '                               ;ce45  fe 3b       ;'
    RET Z                               ;ce47  c8          
    CP  '<'                             ;ce48  fe 3c       
    RET Z                               ;ce4a  c8          
    CP  '>'                             ;ce4b  fe 3e       
    RET Z                               ;ce4d  c8          
    RET                                 ;ce4e  c9          
                  ;
                  ;   Get the next non-blank character from (DE).
                  ;
NONBLANK: LD    A,(DE)                  ;ce4f  1a          
    OR  A                               ;ce50  b7          ;string ends with a null.
    RET Z                               ;ce51  c8          
    CP  ' '                             ;ce52  fe 20       
    RET NZ                              ;ce54  c0          
    INC DE                              ;ce55  13          
    JP  NONBLANK                        ;ce56  c3 4f ce    
                  ;
                  ;   Add (HL)=(HL)+(A)
                  ;
ADDHL:  ADD A,L                         ;ce59  85          
    LD  L,A                             ;ce5a  6f          
    RET NC                              ;ce5b  d0          ;take care of any carry.
    INC H                               ;ce5c  24          
    RET                                 ;ce5d  c9          
                  ;
                  ;   Convert the first name in (FCB).
                  ;
CONVFST:LD  A,0                         ;ce5e  3e 00       
                  ;
                  ;   Format a file name (convert * to '?', etc.). On return,
                  ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
                  ; the position within the fcb for the name (either 0 or 16).
                  ;
CONVERT:LD  HL,FCB                      ;ce60  21 cd d3    
    CALL    ADDHL                       ;ce63  cd 59 ce    
    PUSH    HL                          ;ce66  e5          
    PUSH    HL                          ;ce67  e5          
    XOR A                               ;ce68  af          
    LD  (CHGDRV),A                      ;ce69  32 f0 d3    ;initialize drive change flag.
    LD  HL,(INPOINT)                    ;ce6c  2a 88 cc    ;set (HL) as pointer into input line.
    EX  DE,HL                           ;ce6f  eb          
    CALL    NONBLANK                    ;ce70  cd 4f ce    ;get next non-blank character.
    EX  DE,HL                           ;ce73  eb          
    LD  (NAMEPNT),HL                    ;ce74  22 8a cc    ;save pointer here for any error message.
    EX  DE,HL                           ;ce77  eb          
    POP HL                              ;ce78  e1          
    LD  A,(DE)                          ;ce79  1a          ;get first character.
    OR  A                               ;ce7a  b7          
    JP  Z,CONVRT1                       ;ce7b  ca 89 ce    
    SBC A,'A'-1                         ;ce7e  de 40       ;might be a drive name, convert to binary.
    LD  B,A                             ;ce80  47          ;and save.
    INC DE                              ;ce81  13          ;check next character for a ':'.
    LD  A,(DE)                          ;ce82  1a          
    CP  ':'                             ;ce83  fe 3a       
    JP  Z,CONVRT2                       ;ce85  ca 90 ce    
    DEC DE                              ;ce88  1b          ;nope, move pointer back to the start of the line.
CONVRT1:LD  A,(CDRIVE)                  ;ce89  3a ef d3    
    LD  (HL),A                          ;ce8c  77          
    JP  CONVRT3                         ;ce8d  c3 96 ce    
CONVRT2:LD  A,B                         ;ce90  78          
    LD  (CHGDRV),A                      ;ce91  32 f0 d3    ;set change in drives flag.
    LD  (HL),B                          ;ce94  70          
    INC DE                              ;ce95  13          
                  ;
                  ;   Convert the basic file name.
                  ;
CONVRT3:LD  B,08H                       ;ce96  06 08       
CONVRT4:CALL    CHECK                   ;ce98  cd 30 ce    
    JP  Z,CONVRT8                       ;ce9b  ca b9 ce    
    INC HL                              ;ce9e  23          
    CP  '*'                             ;ce9f  fe 2a       ;note that an '*' will fill the remaining
    JP  NZ,CONVRT5                      ;cea1  c2 a9 ce    ;field with '?'.
    LD  (HL),'?'                        ;cea4  36 3f       
    JP  CONVRT6                         ;cea6  c3 ab ce    
CONVRT5:LD  (HL),A                      ;cea9  77          
    INC DE                              ;ceaa  13          
CONVRT6:DEC B                           ;ceab  05          
    JP  NZ,CONVRT4                      ;ceac  c2 98 ce    
CONVRT7:CALL    CHECK                   ;ceaf  cd 30 ce    ;get next delimiter.
    JP  Z,GETEXT                        ;ceb2  ca c0 ce    
    INC DE                              ;ceb5  13          
    JP  CONVRT7                         ;ceb6  c3 af ce    
CONVRT8:INC HL                          ;ceb9  23          ;blank fill the file name.
    LD  (HL),' '                        ;ceba  36 20       
    DEC B                               ;cebc  05          
    JP  NZ,CONVRT8                      ;cebd  c2 b9 ce    
                  ;
                  ;   Get the extension and convert it.
                  ;
GETEXT: LD  B,03H                       ;cec0  06 03       
    CP  '.'                             ;cec2  fe 2e       
    JP  NZ,GETEXT5                      ;cec4  c2 e9 ce    
    INC DE                              ;cec7  13          
GETEXT1:CALL    CHECK                   ;cec8  cd 30 ce    
    JP  Z,GETEXT5                       ;cecb  ca e9 ce    
    INC HL                              ;cece  23          
    CP  '*'                             ;cecf  fe 2a       
    JP  NZ,GETEXT2                      ;ced1  c2 d9 ce    
    LD  (HL),'?'                        ;ced4  36 3f       
    JP  GETEXT3                         ;ced6  c3 db ce    
GETEXT2:LD  (HL),A                      ;ced9  77          
    INC DE                              ;ceda  13          
GETEXT3:DEC B                           ;cedb  05          
    JP  NZ,GETEXT1                      ;cedc  c2 c8 ce    
GETEXT4:CALL    CHECK                   ;cedf  cd 30 ce    
    JP  Z,GETEXT6                       ;cee2  ca f0 ce    
    INC DE                              ;cee5  13          
    JP  GETEXT4                         ;cee6  c3 df ce    
GETEXT5:INC HL                          ;cee9  23          
    LD  (HL),' '                        ;ceea  36 20       
    DEC B                               ;ceec  05          
    JP  NZ,GETEXT5                      ;ceed  c2 e9 ce    
GETEXT6:LD  B,3                         ;cef0  06 03       
GETEXT7:INC HL                          ;cef2  23          
    LD  (HL),0                          ;cef3  36 00       
    DEC B                               ;cef5  05          
    JP  NZ,GETEXT7                      ;cef6  c2 f2 ce    
    EX  DE,HL                           ;cef9  eb          
    LD  (INPOINT),HL                    ;cefa  22 88 cc    ;save input line pointer.
    POP HL                              ;cefd  e1          
                  ;
                  ;   Check to see if this is an ambigeous file name specification.
                  ; Set the (A) register to non zero if it is.
                  ;
    LD  BC,11                           ;cefe  01 0b 00    ;set name length.
GETEXT8:INC HL                          ;cf01  23          
    LD  A,(HL)                          ;cf02  7e          
    CP  '?'                             ;cf03  fe 3f       ;any question marks?
    JP  NZ,GETEXT9                      ;cf05  c2 09 cf    
    INC B                               ;cf08  04          ;count them.
GETEXT9:DEC C                           ;cf09  0d          
    JP  NZ,GETEXT8                      ;cf0a  c2 01 cf    
    LD  A,B                             ;cf0d  78          
    OR  A                               ;cf0e  b7          
    RET                                 ;cf0f  c9          
                  ;
                  ;   CP/M command table. Note commands can be either 3 or 4 characters long.
                  ;
NUMCMDS EQU 6                           ;0006              ;number of commands
CMDTBL: DEFB    'DIR '                  ;cf10  44 49 52 20 
    DEFB    'ERA '                      ;cf14  45 52 41 20 
    DEFB    'TYPE'                      ;cf18  54 59 50 45 
    DEFB    'SAVE'                      ;cf1c  53 41 56 45 
    DEFB    'REN '                      ;cf20  52 45 4e 20 
    DEFB    'USER'                      ;cf24  55 53 45 52 
                  ;
                  ;   The following six bytes must agree with those at (PATTRN2)
                  ; or cp/m will HALT. Why?
                  ;
PATTRN1:DEFB    0,22,0,0,0,0            ;cf28  00 16 00 00 ;(* serial number bytes *).
                                        ;cf2c  00 00          561    590
                  ;
                  ;   Search the command table for a match with what has just
                  ; been entered. If a match is found, then we jump to the
                  ; proper section. Else jump to (UNKNOWN).
                  ; On return, the (C) register is set to the command number
                  ; that matched (or NUMCMDS+1 if no match).
                  ;
SEARCH: LD  HL,CMDTBL                   ;cf2e  21 10 cf    
    LD  C,0                             ;cf31  0e 00       
SEARCH1:LD  A,C                         ;cf33  79          
    CP  NUMCMDS                         ;cf34  fe 06       ;this commands exists.
    RET NC                              ;cf36  d0          
    LD  DE,FCB+1                        ;cf37  11 ce d3    ;check this one.
    LD  B,4                             ;cf3a  06 04       ;max command length.
SEARCH2:LD  A,(DE)                      ;cf3c  1a          
    CP  (HL)                            ;cf3d  be          
    JP  NZ,SEARCH3                      ;cf3e  c2 4f cf    ;not a match.
    INC DE                              ;cf41  13          
    INC HL                              ;cf42  23          
    DEC B                               ;cf43  05          
    JP  NZ,SEARCH2                      ;cf44  c2 3c cf    
    LD  A,(DE)                          ;cf47  1a          ;allow a 3 character command to match.
    CP  ' '                             ;cf48  fe 20       
    JP  NZ,SEARCH4                      ;cf4a  c2 54 cf    
    LD  A,C                             ;cf4d  79          ;set return register for this command.
    RET                                 ;cf4e  c9          
SEARCH3:INC HL                          ;cf4f  23          
    DEC B                               ;cf50  05          
    JP  NZ,SEARCH3                      ;cf51  c2 4f cf    
SEARCH4:INC C                           ;cf54  0c          
    JP  SEARCH1                         ;cf55  c3 33 cf    
                  ;
                  ;   Set the input buffer to empty and then start the command
                  ; processor (ccp).
                  ;
CLEARBUF: XOR   A                       ;cf58  af          
    LD  (INBUFF+1),A                    ;cf59  32 07 cc    ;second byte is actual length.
                  ;
                  ;**************************************************************
                  ;*
                  ;*
                  ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
                  ;*
                  ;**************************************************************
                  ;*
COMMAND:LD  SP,CCPSTACK                 ;cf5c  31 ab d3    ;setup stack area.
    PUSH    BC                          ;cf5f  c5          ;note that (C) should be equal to:
    LD  A,C                             ;cf60  79          ;(uuuudddd) where 'uuuu' is the user number
    RRA                                 ;cf61  1f          ;and 'dddd' is the drive number.
    RRA                                 ;cf62  1f          
    RRA                                 ;cf63  1f          
    RRA                                 ;cf64  1f          
    AND 0FH                             ;cf65  e6 0f       ;isolate the user number.
    LD  E,A                             ;cf67  5f          
    CALL    GETSETUC                    ;cf68  cd 15 cd    ;and set it.
    CALL    RESDSK                      ;cf6b  cd b8 cc    ;reset the disk system.
    LD  (BATCH),A                       ;cf6e  32 ab d3    ;clear batch mode flag.
    POP BC                              ;cf71  c1          
    LD  A,C                             ;cf72  79          
    AND 0FH                             ;cf73  e6 0f       ;isolate the drive number.
    LD  (CDRIVE),A                      ;cf75  32 ef d3    ;and save.
    CALL    DSKSEL                      ;cf78  cd bd cc    ;...and select.
    LD  A,(INBUFF+1)                    ;cf7b  3a 07 cc    
    OR  A                               ;cf7e  b7          ;anything in input buffer already?
    JP  NZ,CMMND2                       ;cf7f  c2 98 cf    ;yes, we just process it.
                  ;
                  ;   Entry point to get a command line from the console.
                  ;
CMMND1: LD  SP,CCPSTACK                 ;cf82  31 ab d3    ;set stack straight.
    CALL    CRLF                        ;cf85  cd 98 cc    ;start a new line on the screen.
    CALL    GETDSK                      ;cf88  cd d0 cd    ;get current drive.
    ADD A,'a'                           ;cf8b  c6 61       
    CALL    PRINT                       ;cf8d  cd 8c cc    ;print current drive.
    LD  A,'>'                           ;cf90  3e 3e       
    CALL    PRINT                       ;cf92  cd 8c cc    ;and add prompt.
    CALL    GETINP                      ;cf95  cd 39 cd    ;get line from user.
                  ;
                  ;   Process command line here.
                  ;
CMMND2: LD  DE,TBUFF                    ;cf98  11 80 00    
    CALL    DMASET                      ;cf9b  cd d8 cd    ;set standard dma address.
    CALL    GETDSK                      ;cf9e  cd d0 cd    
    LD  (CDRIVE),A                      ;cfa1  32 ef d3    ;set current drive.
    CALL    CONVFST                     ;cfa4  cd 5e ce    ;convert name typed in.
    CALL    NZ,SYNERR                   ;cfa7  c4 09 ce    ;wild cards are not allowed.
    LD  A,(CHGDRV)                      ;cfaa  3a f0 d3    ;if a change in drives was indicated,
    OR  A                               ;cfad  b7          ;then treat this as an unknown command
    JP  NZ,UNKNOWN                      ;cfae  c2 a5 d2    ;which gets executed.
    CALL    SEARCH                      ;cfb1  cd 2e cf    ;else search command table for a match.
                  ;
                  ;   Note that an unknown command returns
                  ; with (A) pointing to the last address
                  ; in our table which is (UNKNOWN).
                  ;
    LD  HL,CMDADR                       ;cfb4  21 c1 cf    ;now, look thru our address table for command (A).
    LD  E,A                             ;cfb7  5f          ;set (DE) to command number.
    LD  D,0                             ;cfb8  16 00       
    ADD HL,DE                           ;cfba  19          
    ADD HL,DE                           ;cfbb  19          ;(HL)=(CMDADR)+2*(command number).
    LD  A,(HL)                          ;cfbc  7e          ;now pick out this address.
    INC HL                              ;cfbd  23          
    LD  H,(HL)                          ;cfbe  66          
    LD  L,A                             ;cfbf  6f          
    JP  (HL)                            ;cfc0  e9          ;now execute it.
                  ;
                  ;   CP/M command address table.
                  ;
CMDADR: DEFW    DIRECT,ERASE,TYPE,SAVE  ;cfc1  77 d0 1f d1 
                                        ;cfc5  5d d1 ad d1    669    699
    DEFW    RENAME,USER,UNKNOWN         ;cfc9  10 d2 8e d2 
                                        ;cfcd  a5 d2          670    701
                  ;
                  ;   Halt the system. Reason for this is unknown at present.
                  ;
HALT:   LD  HL,76F3H                    ;cfcf  21 f3 76    ;'DI HLT' instructions.
    LD  (CBASE),HL                      ;cfd2  22 00 cc    
    LD  HL,CBASE                        ;cfd5  21 00 cc    
    JP  (HL)                            ;cfd8  e9          
                  ;
                  ;   Read error while TYPEing a file.
                  ;
RDERROR:LD  BC,RDERR                    ;cfd9  01 df cf    
    JP  PLINE                           ;cfdc  c3 a7 cc    
RDERR:  DEFB    'Read error',0          ;cfdf  52 65 61 64 
                                        ;cfe3  20 65 72 72    683    715
                                        ;cfe7  6f 72 00       683    716
                  ;
                  ;   Required file was not located.
                  ;
NONE:   LD  BC,NOFILE                   ;cfea  01 f0 cf    
    JP  PLINE                           ;cfed  c3 a7 cc    
NOFILE: DEFB    'No file',0             ;cff0  4e 6f 20 66 
                                        ;cff4  69 6c 65 00    689    723
                  ;
                  ;   Decode a command of the form 'A>filename number{ filename}.
                  ; Note that a drive specifier is not allowed on the first file
                  ; name. On return, the number is in register (A). Any error
                  ; causes 'filename?' to be printed and the command is aborted.
                  ;
DECODE: CALL    CONVFST                 ;cff8  cd 5e ce    ;convert filename.
    LD  A,(CHGDRV)                      ;cffb  3a f0 d3    ;do not allow a drive to be specified.
    OR  A                               ;cffe  b7          
    JP  NZ,SYNERR                       ;cfff  c2 09 ce    
    LD  HL,FCB+1                        ;d002  21 ce d3    ;convert number now.
    LD  BC,11                           ;d005  01 0b 00    ;(B)=sum register, (C)=max digit count.
DECODE1:LD  A,(HL)                      ;d008  7e          
    CP  ' '                             ;d009  fe 20       ;a space terminates the numeral.
    JP  Z,DECODE3                       ;d00b  ca 33 d0    
    INC HL                              ;d00e  23          
    SUB '0'                             ;d00f  d6 30       ;make binary from ascii.
    CP  10                              ;d011  fe 0a       ;legal digit?
    JP  NC,SYNERR                       ;d013  d2 09 ce    
    LD  D,A                             ;d016  57          ;yes, save it in (D).
    LD  A,B                             ;d017  78          ;compute (B)=(B)*10 and check for overflow.
    AND 0E0H                            ;d018  e6 e0       
    JP  NZ,SYNERR                       ;d01a  c2 09 ce    
    LD  A,B                             ;d01d  78          
    RLCA                                ;d01e  07          
    RLCA                                ;d01f  07          
    RLCA                                ;d020  07          ;(A)=(B)*8
    ADD A,B                             ;d021  80          ;.......*9
    JP  C,SYNERR                        ;d022  da 09 ce    
    ADD A,B                             ;d025  80          ;.......*10
    JP  C,SYNERR                        ;d026  da 09 ce    
    ADD A,D                             ;d029  82          ;add in new digit now.
DECODE2:JP  C,SYNERR                    ;d02a  da 09 ce    
    LD  B,A                             ;d02d  47          ;and save result.
    DEC C                               ;d02e  0d          ;only look at 11 digits.
    JP  NZ,DECODE1                      ;d02f  c2 08 d0    
    RET                                 ;d032  c9          
DECODE3:LD  A,(HL)                      ;d033  7e          ;spaces must follow (why?).
    CP  ' '                             ;d034  fe 20       
    JP  NZ,SYNERR                       ;d036  c2 09 ce    
    INC HL                              ;d039  23          
DECODE4:DEC C                           ;d03a  0d          
    JP  NZ,DECODE3                      ;d03b  c2 33 d0    
    LD  A,B                             ;d03e  78          ;set (A)=the numeric value entered.
    RET                                 ;d03f  c9          
                  ;
                  ;   Move 3 bytes from (HL) to (DE). Note that there is only
                  ; one reference to this at (A2D5h).
                  ;
MOVE3:  LD  B,3                         ;d040  06 03       
                  ;
                  ;   Move (B) bytes from (HL) to (DE).
                  ;
HL2DE:  LD  A,(HL)                      ;d042  7e          
    LD  (DE),A                          ;d043  12          
    INC HL                              ;d044  23          
    INC DE                              ;d045  13          
    DEC B                               ;d046  05          
    JP  NZ,HL2DE                        ;d047  c2 42 d0    
    RET                                 ;d04a  c9          
                  ;
                  ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
                  ;
EXTRACT:LD  HL,TBUFF                    ;d04b  21 80 00    
    ADD A,C                             ;d04e  81          
    CALL    ADDHL                       ;d04f  cd 59 ce    
    LD  A,(HL)                          ;d052  7e          
    RET                                 ;d053  c9          
                  ;
                  ;  Check drive specified. If it means a change, then the new
                  ; drive will be selected. In any case, the drive byte of the
                  ; fcb will be set to null (means use current drive).
                  ;
DSELECT:XOR A                           ;d054  af          ;null out first byte of fcb.
    LD  (FCB),A                         ;d055  32 cd d3    
    LD  A,(CHGDRV)                      ;d058  3a f0 d3    ;a drive change indicated?
    OR  A                               ;d05b  b7          
    RET Z                               ;d05c  c8          
    DEC A                               ;d05d  3d          ;yes, is it the same as the current drive?
    LD  HL,CDRIVE                       ;d05e  21 ef d3    
    CP  (HL)                            ;d061  be          
    RET Z                               ;d062  c8          
    JP  DSKSEL                          ;d063  c3 bd cc    ;no. Select it then.
                  ;
                  ;   Check the drive selection and reset it to the previous
                  ; drive if it was changed for the preceeding command.
                  ;
RESETDR:LD  A,(CHGDRV)                  ;d066  3a f0 d3    ;drive change indicated?
    OR  A                               ;d069  b7          
    RET Z                               ;d06a  c8          
    DEC A                               ;d06b  3d          ;yes, was it a different drive?
    LD  HL,CDRIVE                       ;d06c  21 ef d3    
    CP  (HL)                            ;d06f  be          
    RET Z                               ;d070  c8          
    LD  A,(CDRIVE)                      ;d071  3a ef d3    ;yes, re-select our old drive.
    JP  DSKSEL                          ;d074  c3 bd cc    
                  ;
                  ;**************************************************************
                  ;*
                  ;*           D I R E C T O R Y   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
DIRECT: CALL    CONVFST                 ;d077  cd 5e ce    ;convert file name.
    CALL    DSELECT                     ;d07a  cd 54 d0    ;select indicated drive.
    LD  HL,FCB+1                        ;d07d  21 ce d3    ;was any file indicated?
    LD  A,(HL)                          ;d080  7e          
    CP  ' '                             ;d081  fe 20       
    JP  NZ,DIRECT2                      ;d083  c2 8f d0    
    LD  B,11                            ;d086  06 0b       ;no. Fill field with '?' - same as *.*.
DIRECT1:LD  (HL),'?'                    ;d088  36 3f       
    INC HL                              ;d08a  23          
    DEC B                               ;d08b  05          
    JP  NZ,DIRECT1                      ;d08c  c2 88 d0    
DIRECT2:LD  E,0                         ;d08f  1e 00       ;set initial cursor position.
    PUSH    DE                          ;d091  d5          
    CALL    SRCHFCB                     ;d092  cd e9 cc    ;get first file name.
    CALL    Z,NONE                      ;d095  cc ea cf    ;none found at all?
DIRECT3:JP  Z,DIRECT9                   ;d098  ca 1b d1    ;terminate if no more names.
    LD  A,(RTNCODE)                     ;d09b  3a ee d3    ;get file's position in segment (0-3).
    RRCA                                ;d09e  0f          
    RRCA                                ;d09f  0f          
    RRCA                                ;d0a0  0f          
    AND 60H                             ;d0a1  e6 60       ;(A)=position*32
    LD  C,A                             ;d0a3  4f          
    LD  A,10                            ;d0a4  3e 0a       
    CALL    EXTRACT                     ;d0a6  cd 4b d0    ;extract the tenth entry in fcb.
    RLA                                 ;d0a9  17          ;check system file status bit.
    JP  C,DIRECT8                       ;d0aa  da 0f d1    ;we don't list them.
    POP DE                              ;d0ad  d1          
    LD  A,E                             ;d0ae  7b          ;bump name count.
    INC E                               ;d0af  1c          
    PUSH    DE                          ;d0b0  d5          
    AND 03H                             ;d0b1  e6 03       ;at end of line?
    PUSH    AF                          ;d0b3  f5          
    JP  NZ,DIRECT4                      ;d0b4  c2 cc d0    
    CALL    CRLF                        ;d0b7  cd 98 cc    ;yes, end this line and start another.
    PUSH    BC                          ;d0ba  c5          
    CALL    GETDSK                      ;d0bb  cd d0 cd    ;start line with ('A:').
    POP BC                              ;d0be  c1          
    ADD A,'A'                           ;d0bf  c6 41       
    CALL    PRINTB                      ;d0c1  cd 92 cc    
    LD  A,':'                           ;d0c4  3e 3a       
    CALL    PRINTB                      ;d0c6  cd 92 cc    
    JP  DIRECT5                         ;d0c9  c3 d4 d0    
DIRECT4:CALL    SPACE                   ;d0cc  cd a2 cc    ;add seperator between file names.
    LD  A,':'                           ;d0cf  3e 3a       
    CALL    PRINTB                      ;d0d1  cd 92 cc    
DIRECT5:CALL    SPACE                   ;d0d4  cd a2 cc    
    LD  B,1                             ;d0d7  06 01       ;'extract' each file name character at a time.
DIRECT6:LD  A,B                         ;d0d9  78          
    CALL    EXTRACT                     ;d0da  cd 4b d0    
    AND 7FH                             ;d0dd  e6 7f       ;strip bit 7 (status bit).
    CP  ' '                             ;d0df  fe 20       ;are we at the end of the name?
    JP  NZ,DRECT65                      ;d0e1  c2 f9 d0    
    POP AF                              ;d0e4  f1          ;yes, don't print spaces at the end of a line.
    PUSH    AF                          ;d0e5  f5          
    CP  3                               ;d0e6  fe 03       
    JP  NZ,DRECT63                      ;d0e8  c2 f7 d0    
    LD  A,9                             ;d0eb  3e 09       ;first check for no extension.
    CALL    EXTRACT                     ;d0ed  cd 4b d0    
    AND 7FH                             ;d0f0  e6 7f       
    CP  ' '                             ;d0f2  fe 20       
    JP  Z,DIRECT7                       ;d0f4  ca 0e d1    ;don't print spaces.
DRECT63:LD  A,' '                       ;d0f7  3e 20       ;else print them.
DRECT65:CALL    PRINTB                  ;d0f9  cd 92 cc    
    INC B                               ;d0fc  04          ;bump to next character psoition.
    LD  A,B                             ;d0fd  78          
    CP  12                              ;d0fe  fe 0c       ;end of the name?
    JP  NC,DIRECT7                      ;d100  d2 0e d1    
    CP  9                               ;d103  fe 09       ;nope, starting extension?
    JP  NZ,DIRECT6                      ;d105  c2 d9 d0    
    CALL    SPACE                       ;d108  cd a2 cc    ;yes, add seperating space.
    JP  DIRECT6                         ;d10b  c3 d9 d0    
DIRECT7:POP AF                          ;d10e  f1          ;get the next file name.
DIRECT8:CALL    CHKCON                  ;d10f  cd c2 cd    ;first check console, quit on anything.
    JP  NZ,DIRECT9                      ;d112  c2 1b d1    
    CALL    SRCHNXT                     ;d115  cd e4 cc    ;get next name.
    JP  DIRECT3                         ;d118  c3 98 d0    ;and continue with our list.
DIRECT9:POP DE                          ;d11b  d1          ;restore the stack and return to command level.
    JP  GETBACK                         ;d11c  c3 86 d3    
                  ;
                  ;**************************************************************
                  ;*
                  ;*                E R A S E   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
ERASE:  CALL    CONVFST                 ;d11f  cd 5e ce    ;convert file name.
    CP  11                              ;d122  fe 0b       ;was '*.*' entered?
    JP  NZ,ERASE1                       ;d124  c2 42 d1    
    LD  BC,YESNO                        ;d127  01 52 d1    ;yes, ask for confirmation.
    CALL    PLINE                       ;d12a  cd a7 cc    
    CALL    GETINP                      ;d12d  cd 39 cd    
    LD  HL,INBUFF+1                     ;d130  21 07 cc    
    DEC (HL)                            ;d133  35          ;must be exactly 'y'.
    JP  NZ,CMMND1                       ;d134  c2 82 cf    
    INC HL                              ;d137  23          
    LD  A,(HL)                          ;d138  7e          
    CP  'Y'                             ;d139  fe 59       
    JP  NZ,CMMND1                       ;d13b  c2 82 cf    
    INC HL                              ;d13e  23          
    LD  (INPOINT),HL                    ;d13f  22 88 cc    ;save input line pointer.
ERASE1: CALL    DSELECT                 ;d142  cd 54 d0    ;select desired disk.
    LD  DE,FCB                          ;d145  11 cd d3    
    CALL    DELETE                      ;d148  cd ef cc    ;delete the file.
    INC A                               ;d14b  3c          
    CALL    Z,NONE                      ;d14c  cc ea cf    ;not there?
    JP  GETBACK                         ;d14f  c3 86 d3    ;return to command level now.
YESNO:  DEFB    'All (y/n)?',0          ;d152  41 6c 6c 20 
                                        ;d156  28 79 2f 6e    899    934
                                        ;d15a  29 3f 00       899    935
                  ;
                  ;**************************************************************
                  ;*
                  ;*            T Y P E   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
TYPE:   CALL    CONVFST                 ;d15d  cd 5e ce    ;convert file name.
    JP  NZ,SYNERR                       ;d160  c2 09 ce    ;wild cards not allowed.
    CALL    DSELECT                     ;d163  cd 54 d0    ;select indicated drive.
    CALL    OPENFCB                     ;d166  cd d0 cc    ;open the file.
    JP  Z,TYPE5                         ;d169  ca a7 d1    ;not there?
    CALL    CRLF                        ;d16c  cd 98 cc    ;ok, start a new line on the screen.
    LD  HL,NBYTES                       ;d16f  21 f1 d3    ;initialize byte counter.
    LD  (HL),0FFH                       ;d172  36 ff       ;set to read first sector.
TYPE1:  LD  HL,NBYTES                   ;d174  21 f1 d3    
TYPE2:  LD  A,(HL)                      ;d177  7e          ;have we written the entire sector?
    CP  128                             ;d178  fe 80       
    JP  C,TYPE3                         ;d17a  da 87 d1    
    PUSH    HL                          ;d17d  e5          ;yes, read in the next one.
    CALL    READFCB                     ;d17e  cd fe cc    
    POP HL                              ;d181  e1          
    JP  NZ,TYPE4                        ;d182  c2 a0 d1    ;end or error?
    XOR A                               ;d185  af          ;ok, clear byte counter.
    LD  (HL),A                          ;d186  77          
TYPE3:  INC (HL)                        ;d187  34          ;count this byte.
    LD  HL,TBUFF                        ;d188  21 80 00    ;and get the (A)th one from the buffer (TBUFF).
    CALL    ADDHL                       ;d18b  cd 59 ce    
    LD  A,(HL)                          ;d18e  7e          
    CP  CNTRLZ                          ;d18f  fe 1a       ;end of file mark?
    JP  Z,GETBACK                       ;d191  ca 86 d3    
    CALL    PRINT                       ;d194  cd 8c cc    ;no, print it.
    CALL    CHKCON                      ;d197  cd c2 cd    ;check console, quit if anything ready.
    JP  NZ,GETBACK                      ;d19a  c2 86 d3    
    JP  TYPE1                           ;d19d  c3 74 d1    
                  ;
                  ;   Get here on an end of file or read error.
                  ;
TYPE4:  DEC A                           ;d1a0  3d          ;read error?
    JP  Z,GETBACK                       ;d1a1  ca 86 d3    
    CALL    RDERROR                     ;d1a4  cd d9 cf    ;yes, print message.
TYPE5:  CALL    RESETDR                 ;d1a7  cd 66 d0    ;and reset proper drive
    JP  SYNERR                          ;d1aa  c3 09 ce    ;now print file name with problem.
                  ;
                  ;**************************************************************
                  ;*
                  ;*            S A V E   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
SAVE:   CALL    DECODE                  ;d1ad  cd f8 cf    ;get numeric number that follows SAVE.
    PUSH    AF                          ;d1b0  f5          ;save number of pages to write.
    CALL    CONVFST                     ;d1b1  cd 5e ce    ;convert file name.
    JP  NZ,SYNERR                       ;d1b4  c2 09 ce    ;wild cards not allowed.
    CALL    DSELECT                     ;d1b7  cd 54 d0    ;select specified drive.
    LD  DE,FCB                          ;d1ba  11 cd d3    ;now delete this file.
    PUSH    DE                          ;d1bd  d5          
    CALL    DELETE                      ;d1be  cd ef cc    
    POP DE                              ;d1c1  d1          
    CALL    CREATE                      ;d1c2  cd 09 cd    ;and create it again.
    JP  Z,SAVE3                         ;d1c5  ca fb d1    ;can't create?
    XOR A                               ;d1c8  af          ;clear record number byte.
    LD  (FCB+32),A                      ;d1c9  32 ed d3    
    POP AF                              ;d1cc  f1          ;convert pages to sectors.
    LD  L,A                             ;d1cd  6f          
    LD  H,0                             ;d1ce  26 00       
    ADD HL,HL                           ;d1d0  29          ;(HL)=number of sectors to write.
    LD  DE,TBASE                        ;d1d1  11 00 01    ;and we start from here.
SAVE1:  LD  A,H                         ;d1d4  7c          ;done yet?
    OR  L                               ;d1d5  b5          
    JP  Z,SAVE2                         ;d1d6  ca f1 d1    
    DEC HL                              ;d1d9  2b          ;nope, count this and compute the start
    PUSH    HL                          ;d1da  e5          ;of the next 128 byte sector.
    LD  HL,128                          ;d1db  21 80 00    
    ADD HL,DE                           ;d1de  19          
    PUSH    HL                          ;d1df  e5          ;save it and set the transfer address.
    CALL    DMASET                      ;d1e0  cd d8 cd    
    LD  DE,FCB                          ;d1e3  11 cd d3    ;write out this sector now.
    CALL    WRTREC                      ;d1e6  cd 04 cd    
    POP DE                              ;d1e9  d1          ;reset (DE) to the start of the last sector.
    POP HL                              ;d1ea  e1          ;restore sector count.
    JP  NZ,SAVE3                        ;d1eb  c2 fb d1    ;write error?
    JP  SAVE1                           ;d1ee  c3 d4 d1    
                  ;
                  ;   Get here after writing all of the file.
                  ;
SAVE2:  LD  DE,FCB                      ;d1f1  11 cd d3    ;now close the file.
    CALL    CLOSE                       ;d1f4  cd da cc    
    INC A                               ;d1f7  3c          ;did it close ok?
    JP  NZ,SAVE4                        ;d1f8  c2 01 d2    
                  ;
                  ;   Print out error message (no space).
                  ;
SAVE3:  LD  BC,NOSPACE                  ;d1fb  01 07 d2    
    CALL    PLINE                       ;d1fe  cd a7 cc    
SAVE4:  CALL    STDDMA                  ;d201  cd d5 cd    ;reset the standard dma address.
    JP  GETBACK                         ;d204  c3 86 d3    
NOSPACE:DEFB    'No space',0            ;d207  4e 6f 20 73 
                                        ;d20b  70 61 63 65    997   1034
                                        ;d20f  00             997   1035
                  ;
                  ;**************************************************************
                  ;*
                  ;*           R E N A M E   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
RENAME: CALL    CONVFST                 ;d210  cd 5e ce    ;convert first file name.
    JP  NZ,SYNERR                       ;d213  c2 09 ce    ;wild cards not allowed.
    LD  A,(CHGDRV)                      ;d216  3a f0 d3    ;remember any change in drives specified.
    PUSH    AF                          ;d219  f5          
    CALL    DSELECT                     ;d21a  cd 54 d0    ;and select this drive.
    CALL    SRCHFCB                     ;d21d  cd e9 cc    ;is this file present?
    JP  NZ,RENAME6                      ;d220  c2 79 d2    ;yes, print error message.
    LD  HL,FCB                          ;d223  21 cd d3    ;yes, move this name into second slot.
    LD  DE,FCB+16                       ;d226  11 dd d3    
    LD  B,16                            ;d229  06 10       
    CALL    HL2DE                       ;d22b  cd 42 d0    
    LD  HL,(INPOINT)                    ;d22e  2a 88 cc    ;get input pointer.
    EX  DE,HL                           ;d231  eb          
    CALL    NONBLANK                    ;d232  cd 4f ce    ;get next non blank character.
    CP  '='                             ;d235  fe 3d       ;only allow an '=' or '_' seperator.
    JP  Z,RENAME1                       ;d237  ca 3f d2    
    CP  '_'                             ;d23a  fe 5f       
    JP  NZ,RENAME5                      ;d23c  c2 73 d2    
RENAME1:EX  DE,HL                       ;d23f  eb          
    INC HL                              ;d240  23          ;ok, skip seperator.
    LD  (INPOINT),HL                    ;d241  22 88 cc    ;save input line pointer.
    CALL    CONVFST                     ;d244  cd 5e ce    ;convert this second file name now.
    JP  NZ,RENAME5                      ;d247  c2 73 d2    ;again, no wild cards.
    POP AF                              ;d24a  f1          ;if a drive was specified, then it
    LD  B,A                             ;d24b  47          ;must be the same as before.
    LD  HL,CHGDRV                       ;d24c  21 f0 d3    
    LD  A,(HL)                          ;d24f  7e          
    OR  A                               ;d250  b7          
    JP  Z,RENAME2                       ;d251  ca 59 d2    
    CP  B                               ;d254  b8          
    LD  (HL),B                          ;d255  70          
    JP  NZ,RENAME5                      ;d256  c2 73 d2    ;they were different, error.
RENAME2:LD  (HL),B                      ;d259  70          ;	reset as per the first file specification.
    XOR A                               ;d25a  af          
    LD  (FCB),A                         ;d25b  32 cd d3    ;clear the drive byte of the fcb.
RENAME3:CALL    SRCHFCB                 ;d25e  cd e9 cc    ;and go look for second file.
    JP  Z,RENAME4                       ;d261  ca 6d d2    ;doesn't exist?
    LD  DE,FCB                          ;d264  11 cd d3    
    CALL    RENAM                       ;d267  cd 0e cd    ;ok, rename the file.
    JP  GETBACK                         ;d26a  c3 86 d3    
                  ;
                  ;   Process rename errors here.
                  ;
RENAME4:CALL    NONE                    ;d26d  cd ea cf    ;file not there.
    JP  GETBACK                         ;d270  c3 86 d3    
RENAME5:CALL    RESETDR                 ;d273  cd 66 d0    ;bad command format.
    JP  SYNERR                          ;d276  c3 09 ce    
RENAME6:LD  BC,EXISTS                   ;d279  01 82 d2    ;destination file already exists.
    CALL    PLINE                       ;d27c  cd a7 cc    
    JP  GETBACK                         ;d27f  c3 86 d3    
EXISTS: DEFB    'File exists',0         ;d282  46 69 6c 65 
                                        ;d286  20 65 78 69   1055   1094
                                        ;d28a  73 74 73 00   1055   1095
                  ;
                  ;**************************************************************
                  ;*
                  ;*             U S E R   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
USER:   CALL    DECODE                  ;d28e  cd f8 cf    ;get numeric value following command.
    CP  16                              ;d291  fe 10       ;legal user number?
    JP  NC,SYNERR                       ;d293  d2 09 ce    
    LD  E,A                             ;d296  5f          ;yes but is there anything else?
    LD  A,(FCB+1)                       ;d297  3a ce d3    
    CP  ' '                             ;d29a  fe 20       
    JP  Z,SYNERR                        ;d29c  ca 09 ce    ;yes, that is not allowed.
    CALL    GETSETUC                    ;d29f  cd 15 cd    ;ok, set user code.
    JP  GETBACK1                        ;d2a2  c3 89 d3    
                  ;
                  ;**************************************************************
                  ;*
                  ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
                  ;*
                  ;**************************************************************
                  ;
UNKNOWN:CALL    VERIFY                  ;d2a5  cd f5 cd    ;check for valid system (why?).
    LD  A,(FCB+1)                       ;d2a8  3a ce d3    ;anything to execute?
    CP  ' '                             ;d2ab  fe 20       
    JP  NZ,UNKWN1                       ;d2ad  c2 c4 d2    
    LD  A,(CHGDRV)                      ;d2b0  3a f0 d3    ;nope, only a drive change?
    OR  A                               ;d2b3  b7          
    JP  Z,GETBACK1                      ;d2b4  ca 89 d3    ;neither???
    DEC A                               ;d2b7  3d          
    LD  (CDRIVE),A                      ;d2b8  32 ef d3    ;ok, store new drive.
    CALL    MOVECD                      ;d2bb  cd 29 cd    ;set (TDRIVE) also.
    CALL    DSKSEL                      ;d2be  cd bd cc    ;and select this drive.
    JP  GETBACK1                        ;d2c1  c3 89 d3    ;then return.
                  ;
                  ;   Here a file name was typed. Prepare to execute it.
                  ;
UNKWN1: LD  DE,FCB+9                    ;d2c4  11 d6 d3    ;an extension specified?
    LD  A,(DE)                          ;d2c7  1a          
    CP  ' '                             ;d2c8  fe 20       
    JP  NZ,SYNERR                       ;d2ca  c2 09 ce    ;yes, not allowed.
UNKWN2: PUSH    DE                      ;d2cd  d5          
    CALL    DSELECT                     ;d2ce  cd 54 d0    ;select specified drive.
    POP DE                              ;d2d1  d1          
    LD  HL,COMFILE                      ;d2d2  21 83 d3    ;set the extension to 'COM'.
    CALL    MOVE3                       ;d2d5  cd 40 d0    
    CALL    OPENFCB                     ;d2d8  cd d0 cc    ;and open this file.
    JP  Z,UNKWN9                        ;d2db  ca 6b d3    ;not present?
                  ;
                  ;   Load in the program.
                  ;
    LD  HL,TBASE                        ;d2de  21 00 01    ;store the program starting here.
UNKWN3: PUSH    HL                      ;d2e1  e5          
    EX  DE,HL                           ;d2e2  eb          
    CALL    DMASET                      ;d2e3  cd d8 cd    ;set transfer address.
    LD  DE,FCB                          ;d2e6  11 cd d3    ;and read the next record.
    CALL    RDREC                       ;d2e9  cd f9 cc    
    JP  NZ,UNKWN4                       ;d2ec  c2 01 d3    ;end of file or read error?
    POP HL                              ;d2ef  e1          ;nope, bump pointer for next sector.
    LD  DE,128                          ;d2f0  11 80 00    
    ADD HL,DE                           ;d2f3  19          
    LD  DE,CBASE                        ;d2f4  11 00 cc    ;enough room for the whole file?
    LD  A,L                             ;d2f7  7d          
    SUB E                               ;d2f8  93          
    LD  A,H                             ;d2f9  7c          
    SBC A,D                             ;d2fa  9a          
    JP  NC,UNKWN0                       ;d2fb  d2 71 d3    ;no, it can't fit.
    JP  UNKWN3                          ;d2fe  c3 e1 d2    
                  ;
                  ;   Get here after finished reading.
                  ;
UNKWN4: POP HL                          ;d301  e1          
    DEC A                               ;d302  3d          ;normal end of file?
    JP  NZ,UNKWN0                       ;d303  c2 71 d3    
    CALL    RESETDR                     ;d306  cd 66 d0    ;yes, reset previous drive.
    CALL    CONVFST                     ;d309  cd 5e ce    ;convert the first file name that follows
    LD  HL,CHGDRV                       ;d30c  21 f0 d3    ;command name.
    PUSH    HL                          ;d30f  e5          
    LD  A,(HL)                          ;d310  7e          ;set drive code in default fcb.
    LD  (FCB),A                         ;d311  32 cd d3    
    LD  A,16                            ;d314  3e 10       ;put second name 16 bytes later.
    CALL    CONVERT                     ;d316  cd 60 ce    ;convert second file name.
    POP HL                              ;d319  e1          
    LD  A,(HL)                          ;d31a  7e          ;and set the drive for this second file.
    LD  (FCB+16),A                      ;d31b  32 dd d3    
    XOR A                               ;d31e  af          ;clear record byte in fcb.
    LD  (FCB+32),A                      ;d31f  32 ed d3    
    LD  DE,TFCB                         ;d322  11 5c 00    ;move it into place at(005Ch).
    LD  HL,FCB                          ;d325  21 cd d3    
    LD  B,33                            ;d328  06 21       
    CALL    HL2DE                       ;d32a  cd 42 d0    
    LD  HL,INBUFF+2                     ;d32d  21 08 cc    ;now move the remainder of the input
UNKWN5: LD  A,(HL)                      ;d330  7e          ;line down to (0080h). Look for a non blank.
    OR  A                               ;d331  b7          ;or a null.
    JP  Z,UNKWN6                        ;d332  ca 3e d3    
    CP  ' '                             ;d335  fe 20       
    JP  Z,UNKWN6                        ;d337  ca 3e d3    
    INC HL                              ;d33a  23          
    JP  UNKWN5                          ;d33b  c3 30 d3    
                  ;
                  ;   Do the line move now. It ends in a null byte.
                  ;
UNKWN6: LD  B,0                         ;d33e  06 00       ;keep a character count.
    LD  DE,TBUFF+1                      ;d340  11 81 00    ;data gets put here.
UNKWN7: LD  A,(HL)                      ;d343  7e          ;move it now.
    LD  (DE),A                          ;d344  12          
    OR  A                               ;d345  b7          
    JP  Z,UNKWN8                        ;d346  ca 4f d3    
    INC B                               ;d349  04          
    INC HL                              ;d34a  23          
    INC DE                              ;d34b  13          
    JP  UNKWN7                          ;d34c  c3 43 d3    
UNKWN8: LD  A,B                         ;d34f  78          ;now store the character count.
    LD  (TBUFF),A                       ;d350  32 80 00    
    CALL    CRLF                        ;d353  cd 98 cc    ;clean up the screen.
    CALL    STDDMA                      ;d356  cd d5 cd    ;set standard transfer address.
    CALL    SETCDRV                     ;d359  cd 1a cd    ;reset current drive.
    CALL    TBASE                       ;d35c  cd 00 01    ;and execute the program.
                  ;
                  ;   Transiant programs return here (or reboot).
                  ;
    LD  SP,BATCH                        ;d35f  31 ab d3    ;set stack first off.
    CALL    MOVECD                      ;d362  cd 29 cd    ;move current drive into place (TDRIVE).
    CALL    DSKSEL                      ;d365  cd bd cc    ;and reselect it.
    JP  CMMND1                          ;d368  c3 82 cf    ;back to comand mode.
                  ;
                  ;   Get here if some error occured.
                  ;
UNKWN9: CALL    RESETDR                 ;d36b  cd 66 d0    ;inproper format.
    JP  SYNERR                          ;d36e  c3 09 ce    
UNKWN0: LD  BC,BADLOAD                  ;d371  01 7a d3    ;read error or won't fit.
    CALL    PLINE                       ;d374  cd a7 cc    
    JP  GETBACK                         ;d377  c3 86 d3    
BADLOAD:DEFB    'Bad load',0            ;d37a  42 61 64 20 
                                        ;d37e  6c 6f 61 64   1190   1231
                                        ;d382  00            1190   1232
COMFILE:DEFB    'COM'                   ;d383  43 4f 4d    ;command file extension.
                  ;
                  ;   Get here to return to command level. We will reset the
                  ; previous active drive and then either return to command
                  ; level directly or print error message and then return.
                  ;
GETBACK:CALL    RESETDR                 ;d386  cd 66 d0    ;reset previous drive.
GETBACK1: CALL  CONVFST                 ;d389  cd 5e ce    ;convert first name in (FCB).
    LD  A,(FCB+1)                       ;d38c  3a ce d3    ;if this was just a drive change request,
    SUB ' '                             ;d38f  d6 20       ;make sure it was valid.
    LD  HL,CHGDRV                       ;d391  21 f0 d3    
    OR  (HL)                            ;d394  b6          
    JP  NZ,SYNERR                       ;d395  c2 09 ce    
    JP  CMMND1                          ;d398  c3 82 cf    ;ok, return to command level.
                  ;
                  ;   ccp stack area.
                  ;
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;d39b  00 00 00 00 
                                        ;d39f  00 00 00 00   1208   1251
                                        ;d3a3  00 00 00 00   1208   1252
                                        ;d3a7  00 00 00 00   1208   1253
CCPSTACK EQU    $                       ;d3ab              ;end of ccp stack area.
                  ;
                  ;   Batch (or SUBMIT) processing information storage.
                  ;
BATCH:  DEFB    0                       ;d3ab  00          ;batch mode flag (0=not active).
BATCHFCB: DEFB  0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;d3ac  00 24 24 24 
                                        ;d3b0  20 20 20 20   1214   1260
                                        ;d3b4  20 53 55 42   1214   1261
                                        ;d3b8  00 00 00 00   1214   1262
                                        ;d3bc  00 00 00 00   1214   1263
                                        ;d3c0  00 00 00 00   1214   1264
                                        ;d3c4  00 00 00 00   1214   1265
                                        ;d3c8  00 00 00 00   1214   1266
                                        ;d3cc  00            1214   1267
                  ;
                  ;   File control block setup by the CCP.
                  ;
FCB:    DEFB    0,'           ',0,0,0,0,0,'           ',0,0,0,0,0;d3cd  00 20 20 20 
                                        ;d3d1  20 20 20 20   1218   1272
                                        ;d3d5  20 20 20 20   1218   1273
                                        ;d3d9  00 00 00 00   1218   1274
                                        ;d3dd  00 20 20 20   1218   1275
                                        ;d3e1  20 20 20 20   1218   1276
                                        ;d3e5  20 20 20 20   1218   1277
                                        ;d3e9  00 00 00 00   1218   1278
                                        ;d3ed  00            1218   1279
RTNCODE:DEFB    0                       ;d3ee  00          ;status returned from bdos call.
CDRIVE: DEFB    0                       ;d3ef  00          ;currently active drive.
CHGDRV: DEFB    0                       ;d3f0  00          ;change in drives flag (0=no change).
NBYTES: DEFW    0                       ;d3f1  00 00       ;byte counter used by TYPE.
                  ;
                  ;   Room for expansion?
                  ;
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0   ;d3f3  00 00 00 00 
                                        ;d3f7  00 00 00 00   1226   1288
                                        ;d3fb  00 00 00 00   1226   1289
                                        ;d3ff  00            1226   1290
                  ;
                  ;   Note that the following six bytes must match those at
                  ; (PATTRN1) or cp/m will HALT. Why?
                  ;
PATTRN2:DEFB    0,22,0,0,0,0            ;d400  00 16 00 00 ;(* serial number bytes *).
                                        ;d404  00 00         1231   1296
                  ;
                  ;**************************************************************
                  ;*
                  ;*                    B D O S   E N T R Y
                  ;*
                  ;**************************************************************
                  ;
FBASE:  JP  FBASE1                      ;d406  c3 11 d4    
                  ;
                  ;   Bdos error table.
                  ;
BADSCTR:DEFW    ERROR1                  ;d409  99 d4       ;bad sector on read or write.
BADSLCT:DEFW    ERROR2                  ;d40b  a5 d4       ;bad disk select.
RODISK: DEFW    ERROR3                  ;d40d  ab d4       ;disk is read only.
ROFILE: DEFW    ERROR4                  ;d40f  b1 d4       ;file is read only.
                  ;
                  ;   Entry into bdos. (DE) or (E) are the parameters passed. The
                  ; function number desired is in register (C).
                  ;
FBASE1: EX  DE,HL                       ;d411  eb          ;save the (DE) parameters.
    LD  (PARAMS),HL                     ;d412  22 43 d7    
    EX  DE,HL                           ;d415  eb          
    LD  A,E                             ;d416  7b          ;and save register (E) in particular.
    LD  (EPARAM),A                      ;d417  32 d6 e1    
    LD  HL,0                            ;d41a  21 00 00    
    LD  (STATUS),HL                     ;d41d  22 45 d7    ;clear return status.
    ADD HL,SP                           ;d420  39          
    LD  (USRSTACK),HL                   ;d421  22 0f d7    ;save users stack pointer.
    LD  SP,STKAREA                      ;d424  31 41 d7    ;and set our own.
    XOR A                               ;d427  af          ;clear auto select storage space.
    LD  (AUTOFLAG),A                    ;d428  32 e0 e1    
    LD  (AUTO),A                        ;d42b  32 de e1    
    LD  HL,GOBACK                       ;d42e  21 74 e1    ;set return address.
    PUSH    HL                          ;d431  e5          
    LD  A,C                             ;d432  79          ;get function number.
    CP  NFUNCTS                         ;d433  fe 29       ;valid function number?
    RET NC                              ;d435  d0          
    LD  C,E                             ;d436  4b          ;keep single register function here.
    LD  HL,FUNCTNS                      ;d437  21 47 d4    ;now look thru the function table.
    LD  E,A                             ;d43a  5f          
    LD  D,0                             ;d43b  16 00       ;(DE)=function number.
    ADD HL,DE                           ;d43d  19          
    ADD HL,DE                           ;d43e  19          ;(HL)=(start of table)+2*(function number).
    LD  E,(HL)                          ;d43f  5e          
    INC HL                              ;d440  23          
    LD  D,(HL)                          ;d441  56          ;now (DE)=address for this function.
    LD  HL,(PARAMS)                     ;d442  2a 43 d7    ;retrieve parameters.
    EX  DE,HL                           ;d445  eb          ;now (DE) has the original parameters.
    JP  (HL)                            ;d446  e9          ;execute desired function.
                  ;
                  ;   BDOS function jump table.
                  ;
NFUNCTS EQU 41                          ;0029              ;number of functions in followin table.
                  ;
FUNCTNS:DEFW    WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB;d447  03 e2 c8 d6 
                                        ;d44b  90 d5 ce d6   1286   1352
                                        ;d44f  12 e2 0f e2   1286   1353
                                        ;d453  d4 d6 ed d6   1286   1354
    DEFW    SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL;d457  f3 d6 f8 d6 
                                        ;d45b  e1 d5 fe d6   1287   1356
                                        ;d45f  7e e0 83 e0   1287   1357
                                        ;d463  45 e0 9c e0   1287   1358
    DEFW    CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE;d467  a5 e0 ab e0 
                                        ;d46b  c8 e0 d7 e0   1288   1360
                                        ;d46f  e0 e0 e6 e0   1288   1361
                                        ;d473  ec e0         1288   1362
    DEFW    RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR;d475  f5 e0 fe e0 
                                        ;d479  04 e1 0a e1   1289   1364
                                        ;d47d  11 e1 2c d9   1289   1365
                                        ;d481  17 e1 1d e1   1289   1366
    DEFW    GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN;d485  26 e1 2d e1 
                                        ;d489  41 e1 47 e1   1290   1368
                                        ;d48d  4d e1 0e e0   1290   1369
                                        ;d491  53 e1 04 d7   1290   1370
    DEFW    RTN,WTSPECL                 ;d495  04 d7 9b e1 
                  ;
                  ;   Bdos error message section.
                  ;
ERROR1: LD  HL,BADSEC                   ;d499  21 ca d4    ;bad sector message.
    CALL    PRTERR                      ;d49c  cd e5 d4    ;print it and get a 1 char responce.
    CP  CNTRLC                          ;d49f  fe 03       ;re-boot request (control-c)?
    JP  Z,0                             ;d4a1  ca 00 00    ;yes.
    RET                                 ;d4a4  c9          ;no, return to retry i/o function.
                  ;
ERROR2: LD  HL,BADSEL                   ;d4a5  21 d5 d4    ;bad drive selected.
    JP  ERROR5                          ;d4a8  c3 b4 d4    
                  ;
ERROR3: LD  HL,DISKRO                   ;d4ab  21 e1 d4    ;disk is read only.
    JP  ERROR5                          ;d4ae  c3 b4 d4    
                  ;
ERROR4: LD  HL,FILERO                   ;d4b1  21 dc d4    ;file is read only.
                  ;
ERROR5: CALL    PRTERR                  ;d4b4  cd e5 d4    
    JP  0                               ;d4b7  c3 00 00    ;always reboot on these errors.
                  ;
BDOSERR:DEFB    'Bdos Err On '          ;d4ba  42 64 6f 73 
                                        ;d4be  20 45 72 72   1312   1393
                                        ;d4c2  20 4f 6e 20   1312   1394
BDOSDRV:DEFB    ' : $'                  ;d4c6  20 3a 20 24 
BADSEC: DEFB    'Bad Sector$'           ;d4ca  42 61 64 20 
                                        ;d4ce  53 65 63 74   1314   1397
                                        ;d4d2  6f 72 24      1314   1398
BADSEL: DEFB    'Select$'               ;d4d5  53 65 6c 65 
                                        ;d4d9  63 74 24      1315   1400
FILERO: DEFB    'File '                 ;d4dc  46 69 6c 65 
                                        ;d4e0  20            1316   1402
DISKRO: DEFB    'R/O$'                  ;d4e1  52 2f 4f 24 
                  ;
                  ;   Print bdos error message.
                  ;
PRTERR: PUSH    HL                      ;d4e5  e5          ;save second message pointer.
    CALL    OUTCRLF                     ;d4e6  cd c9 d5    ;send (cr)(lf).
    LD  A,(ACTIVE)                      ;d4e9  3a 42 d7    ;get active drive.
    ADD A,'A'                           ;d4ec  c6 41       ;make ascii.
    LD  (BDOSDRV),A                     ;d4ee  32 c6 d4    ;and put in message.
    LD  BC,BDOSERR                      ;d4f1  01 ba d4    ;and print it.
    CALL    PRTMESG                     ;d4f4  cd d3 d5    
    POP BC                              ;d4f7  c1          ;print second message line now.
    CALL    PRTMESG                     ;d4f8  cd d3 d5    
                  ;
                  ;   Get an input character. We will check our 1 character
                  ; buffer first. This may be set by the console status routine.
                  ;
GETCHAR:LD  HL,CHARBUF                  ;d4fb  21 0e d7    ;check character buffer.
    LD  A,(HL)                          ;d4fe  7e          ;anything present already?
    LD  (HL),0                          ;d4ff  36 00       ;...either case clear it.
    OR  A                               ;d501  b7          
    RET NZ                              ;d502  c0          ;yes, use it.
    JP  CONIN                           ;d503  c3 09 e2    ;nope, go get a character responce.
                  ;
                  ;   Input and echo a character.
                  ;
GETECHO:CALL    GETCHAR                 ;d506  cd fb d4    ;input a character.
    CALL    CHKCHAR                     ;d509  cd 14 d5    ;carriage control?
    RET C                               ;d50c  d8          ;no, a regular control char so don't echo.
    PUSH    AF                          ;d50d  f5          ;ok, save character now.
    LD  C,A                             ;d50e  4f          
    CALL    OUTCON                      ;d50f  cd 90 d5    ;and echo it.
    POP AF                              ;d512  f1          ;get character and return.
    RET                                 ;d513  c9          
                  ;
                  ;   Check character in (A). Set the zero flag on a carriage
                  ; control character and the carry flag on any other control
                  ; character.
                  ;
CHKCHAR:CP  CR                          ;d514  fe 0d       ;check for carriage return, line feed, backspace,
    RET Z                               ;d516  c8          ;or a tab.
    CP  LF                              ;d517  fe 0a       
    RET Z                               ;d519  c8          
    CP  TAB                             ;d51a  fe 09       
    RET Z                               ;d51c  c8          
    CP  BS                              ;d51d  fe 08       
    RET Z                               ;d51f  c8          
    CP  ' '                             ;d520  fe 20       ;other control char? Set carry flag.
    RET                                 ;d522  c9          
                  ;
                  ;   Check the console during output. Halt on a control-s, then
                  ; reboot on a control-c. If anything else is ready, clear the
                  ; zero flag and return (the calling routine may want to do
                  ; something).
                  ;
CKCONSOL: LD    A,(CHARBUF)             ;d523  3a 0e d7    ;check buffer.
    OR  A                               ;d526  b7          ;if anything, just return without checking.
    JP  NZ,CKCON2                       ;d527  c2 45 d5    
    CALL    CONST                       ;d52a  cd 06 e2    ;nothing in buffer. Check console.
    AND 01H                             ;d52d  e6 01       ;look at bit 0.
    RET Z                               ;d52f  c8          ;return if nothing.
    CALL    CONIN                       ;d530  cd 09 e2    ;ok, get it.
    CP  CNTRLS                          ;d533  fe 13       ;if not control-s, return with zero cleared.
    JP  NZ,CKCON1                       ;d535  c2 42 d5    
    CALL    CONIN                       ;d538  cd 09 e2    ;halt processing until another char
    CP  CNTRLC                          ;d53b  fe 03       ;is typed. Control-c?
    JP  Z,0                             ;d53d  ca 00 00    ;yes, reboot now.
    XOR A                               ;d540  af          ;no, just pretend nothing was ever ready.
    RET                                 ;d541  c9          
CKCON1: LD  (CHARBUF),A                 ;d542  32 0e d7    ;save character in buffer for later processing.
CKCON2: LD  A,1                         ;d545  3e 01       ;set (A) to non zero to mean something is ready.
    RET                                 ;d547  c9          
                  ;
                  ;   Output (C) to the screen. If the printer flip-flop flag
                  ; is set, we will send character to printer also. The console
                  ; will be checked in the process.
                  ;
OUTCHAR:LD  A,(OUTFLAG)                 ;d548  3a 0a d7    ;check output flag.
    OR  A                               ;d54b  b7          ;anything and we won't generate output.
    JP  NZ,OUTCHR1                      ;d54c  c2 62 d5    
    PUSH    BC                          ;d54f  c5          
    CALL    CKCONSOL                    ;d550  cd 23 d5    ;check console (we don't care whats there).
    POP BC                              ;d553  c1          
    PUSH    BC                          ;d554  c5          
    CALL    CONOUT                      ;d555  cd 0c e2    ;output (C) to the screen.
    POP BC                              ;d558  c1          
    PUSH    BC                          ;d559  c5          
    LD  A,(PRTFLAG)                     ;d55a  3a 0d d7    ;check printer flip-flop flag.
    OR  A                               ;d55d  b7          
    CALL    NZ,LIST                     ;d55e  c4 0f e2    ;print it also if non-zero.
    POP BC                              ;d561  c1          
OUTCHR1:LD  A,C                         ;d562  79          ;update cursors position.
    LD  HL,CURPOS                       ;d563  21 0c d7    
    CP  DEL                             ;d566  fe 7f       ;rubouts don't do anything here.
    RET Z                               ;d568  c8          
    INC (HL)                            ;d569  34          ;bump line pointer.
    CP  ' '                             ;d56a  fe 20       ;and return if a normal character.
    RET NC                              ;d56c  d0          
    DEC (HL)                            ;d56d  35          ;restore and check for the start of the line.
    LD  A,(HL)                          ;d56e  7e          
    OR  A                               ;d56f  b7          
    RET Z                               ;d570  c8          ;ingnore control characters at the start of the line.
    LD  A,C                             ;d571  79          
    CP  BS                              ;d572  fe 08       ;is it a backspace?
    JP  NZ,OUTCHR2                      ;d574  c2 79 d5    
    DEC (HL)                            ;d577  35          ;yes, backup pointer.
    RET                                 ;d578  c9          
OUTCHR2:CP  LF                          ;d579  fe 0a       ;is it a line feed?
    RET NZ                              ;d57b  c0          ;ignore anything else.
    LD  (HL),0                          ;d57c  36 00       ;reset pointer to start of line.
    RET                                 ;d57e  c9          
                  ;
                  ;   Output (A) to the screen. If it is a control character
                  ; (other than carriage control), use ^x format.
                  ;
SHOWIT: LD  A,C                         ;d57f  79          
    CALL    CHKCHAR                     ;d580  cd 14 d5    ;check character.
    JP  NC,OUTCON                       ;d583  d2 90 d5    ;not a control, use normal output.
    PUSH    AF                          ;d586  f5          
    LD  C,'^'                           ;d587  0e 5e       ;for a control character, preceed it with '^'.
    CALL    OUTCHAR                     ;d589  cd 48 d5    
    POP AF                              ;d58c  f1          
    OR  '@'                             ;d58d  f6 40       ;and then use the letter equivelant.
    LD  C,A                             ;d58f  4f          
                  ;
                  ;   Function to output (C) to the console device and expand tabs
                  ; if necessary.
                  ;
OUTCON: LD  A,C                         ;d590  79          
    CP  TAB                             ;d591  fe 09       ;is it a tab?
    JP  NZ,OUTCHAR                      ;d593  c2 48 d5    ;use regular output.
OUTCON1:LD  C,' '                       ;d596  0e 20       ;yes it is, use spaces instead.
    CALL    OUTCHAR                     ;d598  cd 48 d5    
    LD  A,(CURPOS)                      ;d59b  3a 0c d7    ;go until the cursor is at a multiple of 8
                  
    AND 07H                             ;d59e  e6 07       ;position.
    JP  NZ,OUTCON1                      ;d5a0  c2 96 d5    
    RET                                 ;d5a3  c9          
                  ;
                  ;   Echo a backspace character. Erase the prevoius character
                  ; on the screen.
                  ;
BACKUP: CALL    BACKUP1                 ;d5a4  cd ac d5    ;backup the screen 1 place.
    LD  C,' '                           ;d5a7  0e 20       ;then blank that character.
    CALL    CONOUT                      ;d5a9  cd 0c e2    
BACKUP1:LD  C,BS                        ;d5ac  0e 08       ;then back space once more.
    JP  CONOUT                          ;d5ae  c3 0c e2    
                  ;
                  ;   Signal a deleted line. Print a '#' at the end and start
                  ; over.
                  ;
NEWLINE:LD  C,'#'                       ;d5b1  0e 23       
    CALL    OUTCHAR                     ;d5b3  cd 48 d5    ;print this.
    CALL    OUTCRLF                     ;d5b6  cd c9 d5    ;start new line.
NEWLN1: LD  A,(CURPOS)                  ;d5b9  3a 0c d7    ;move the cursor to the starting position.
    LD  HL,STARTING                     ;d5bc  21 0b d7    
    CP  (HL)                            ;d5bf  be          
    RET NC                              ;d5c0  d0          ;there yet?
    LD  C,' '                           ;d5c1  0e 20       
    CALL    OUTCHAR                     ;d5c3  cd 48 d5    ;nope, keep going.
    JP  NEWLN1                          ;d5c6  c3 b9 d5    
                  ;
                  ;   Output a (cr) (lf) to the console device (screen).
                  ;
OUTCRLF:LD  C,CR                        ;d5c9  0e 0d       
    CALL    OUTCHAR                     ;d5cb  cd 48 d5    
    LD  C,LF                            ;d5ce  0e 0a       
    JP  OUTCHAR                         ;d5d0  c3 48 d5    
                  ;
                  ;   Print message pointed to by (BC). It will end with a '$'.
                  ;
PRTMESG:LD  A,(BC)                      ;d5d3  0a          ;check for terminating character.
    CP  '$'                             ;d5d4  fe 24       
    RET Z                               ;d5d6  c8          
    INC BC                              ;d5d7  03          
    PUSH    BC                          ;d5d8  c5          ;otherwise, bump pointer and print it.
    LD  C,A                             ;d5d9  4f          
    CALL    OUTCON                      ;d5da  cd 90 d5    
    POP BC                              ;d5dd  c1          
    JP  PRTMESG                         ;d5de  c3 d3 d5    
                  ;
                  ;   Function to execute a buffered read.
                  ;
RDBUFF: LD  A,(CURPOS)                  ;d5e1  3a 0c d7    ;use present location as starting one.
    LD  (STARTING),A                    ;d5e4  32 0b d7    
    LD  HL,(PARAMS)                     ;d5e7  2a 43 d7    ;get the maximum buffer space.
    LD  C,(HL)                          ;d5ea  4e          
    INC HL                              ;d5eb  23          ;point to first available space.
    PUSH    HL                          ;d5ec  e5          ;and save.
    LD  B,0                             ;d5ed  06 00       ;keep a character count.
RDBUF1: PUSH    BC                      ;d5ef  c5          
    PUSH    HL                          ;d5f0  e5          
RDBUF2: CALL    GETCHAR                 ;d5f1  cd fb d4    ;get the next input character.
    AND 7FH                             ;d5f4  e6 7f       ;strip bit 7.
    POP HL                              ;d5f6  e1          ;reset registers.
    POP BC                              ;d5f7  c1          
    CP  CR                              ;d5f8  fe 0d       ;en of the line?
    JP  Z,RDBUF17                       ;d5fa  ca c1 d6    
    CP  LF                              ;d5fd  fe 0a       
    JP  Z,RDBUF17                       ;d5ff  ca c1 d6    
    CP  BS                              ;d602  fe 08       ;how about a backspace?
    JP  NZ,RDBUF3                       ;d604  c2 16 d6    
    LD  A,B                             ;d607  78          ;yes, but ignore at the beginning of the line.
    OR  A                               ;d608  b7          
    JP  Z,RDBUF1                        ;d609  ca ef d5    
    DEC B                               ;d60c  05          ;ok, update counter.
    LD  A,(CURPOS)                      ;d60d  3a 0c d7    ;if we backspace to the start of the line,
    LD  (OUTFLAG),A                     ;d610  32 0a d7    ;treat as a cancel (control-x).
    JP  RDBUF10                         ;d613  c3 70 d6    
RDBUF3: CP  DEL                         ;d616  fe 7f       ;user typed a rubout?
    JP  NZ,RDBUF4                       ;d618  c2 26 d6    
    LD  A,B                             ;d61b  78          ;ignore at the start of the line.
    OR  A                               ;d61c  b7          
    JP  Z,RDBUF1                        ;d61d  ca ef d5    
    LD  A,(HL)                          ;d620  7e          ;ok, echo the prevoius character.
    DEC B                               ;d621  05          ;and reset pointers (counters).
    DEC HL                              ;d622  2b          
    JP  RDBUF15                         ;d623  c3 a9 d6    
RDBUF4: CP  CNTRLE                      ;d626  fe 05       ;physical end of line?
    JP  NZ,RDBUF5                       ;d628  c2 37 d6    
    PUSH    BC                          ;d62b  c5          ;yes, do it.
    PUSH    HL                          ;d62c  e5          
    CALL    OUTCRLF                     ;d62d  cd c9 d5    
    XOR A                               ;d630  af          ;and update starting position.
    LD  (STARTING),A                    ;d631  32 0b d7    
    JP  RDBUF2                          ;d634  c3 f1 d5    
RDBUF5: CP  CNTRLP                      ;d637  fe 10       ;control-p?
    JP  NZ,RDBUF6                       ;d639  c2 48 d6    
    PUSH    HL                          ;d63c  e5          ;yes, flip the print flag filp-flop byte.
    LD  HL,PRTFLAG                      ;d63d  21 0d d7    
    LD  A,1                             ;d640  3e 01       ;PRTFLAG=1-PRTFLAG
    SUB (HL)                            ;d642  96          
    LD  (HL),A                          ;d643  77          
    POP HL                              ;d644  e1          
    JP  RDBUF1                          ;d645  c3 ef d5    
RDBUF6: CP  CNTRLX                      ;d648  fe 18       ;control-x (cancel)?
    JP  NZ,RDBUF8                       ;d64a  c2 5f d6    
    POP HL                              ;d64d  e1          
RDBUF7: LD  A,(STARTING)                ;d64e  3a 0b d7    ;yes, backup the cursor to here.
    LD  HL,CURPOS                       ;d651  21 0c d7    
    CP  (HL)                            ;d654  be          
    JP  NC,RDBUFF                       ;d655  d2 e1 d5    ;done yet?
    DEC (HL)                            ;d658  35          ;no, decrement pointer and output back up one space.
    CALL    BACKUP                      ;d659  cd a4 d5    
    JP  RDBUF7                          ;d65c  c3 4e d6    
RDBUF8: CP  CNTRLU                      ;d65f  fe 15       ;cntrol-u (cancel line)?
    JP  NZ,RDBUF9                       ;d661  c2 6b d6    
    CALL    NEWLINE                     ;d664  cd b1 d5    ;start a new line.
    POP HL                              ;d667  e1          
    JP  RDBUFF                          ;d668  c3 e1 d5    
RDBUF9: CP  CNTRLR                      ;d66b  fe 12       ;control-r?
    JP  NZ,RDBUF14                      ;d66d  c2 a6 d6    
RDBUF10:PUSH    BC                      ;d670  c5          ;yes, start a new line and retype the old one.
    CALL    NEWLINE                     ;d671  cd b1 d5    
    POP BC                              ;d674  c1          
    POP HL                              ;d675  e1          
    PUSH    HL                          ;d676  e5          
    PUSH    BC                          ;d677  c5          
RDBUF11:LD  A,B                         ;d678  78          ;done whole line yet?
    OR  A                               ;d679  b7          
    JP  Z,RDBUF12                       ;d67a  ca 8a d6    
    INC HL                              ;d67d  23          ;nope, get next character.
    LD  C,(HL)                          ;d67e  4e          
    DEC B                               ;d67f  05          ;count it.
    PUSH    BC                          ;d680  c5          
    PUSH    HL                          ;d681  e5          
    CALL    SHOWIT                      ;d682  cd 7f d5    ;and display it.
    POP HL                              ;d685  e1          
    POP BC                              ;d686  c1          
    JP  RDBUF11                         ;d687  c3 78 d6    
RDBUF12:PUSH    HL                      ;d68a  e5          ;done with line. If we were displaying
    LD  A,(OUTFLAG)                     ;d68b  3a 0a d7    ;then update cursor position.
    OR  A                               ;d68e  b7          
    JP  Z,RDBUF2                        ;d68f  ca f1 d5    
    LD  HL,CURPOS                       ;d692  21 0c d7    ;because this line is shorter, we must
    SUB (HL)                            ;d695  96          ;back up the cursor (not the screen however)
    LD  (OUTFLAG),A                     ;d696  32 0a d7    ;some number of positions.
RDBUF13:CALL    BACKUP                  ;d699  cd a4 d5    ;note that as long as (OUTFLAG) is non
    LD  HL,OUTFLAG                      ;d69c  21 0a d7    ;zero, the screen will not be changed.
    DEC (HL)                            ;d69f  35          
    JP  NZ,RDBUF13                      ;d6a0  c2 99 d6    
    JP  RDBUF2                          ;d6a3  c3 f1 d5    ;now just get the next character.
                  ;
                  ;   Just a normal character, put this in our buffer and echo.
                  ;
RDBUF14:INC HL                          ;d6a6  23          
    LD  (HL),A                          ;d6a7  77          ;store character.
    INC B                               ;d6a8  04          ;and count it.
RDBUF15:PUSH    BC                      ;d6a9  c5          
    PUSH    HL                          ;d6aa  e5          
    LD  C,A                             ;d6ab  4f          ;echo it now.
    CALL    SHOWIT                      ;d6ac  cd 7f d5    
    POP HL                              ;d6af  e1          
    POP BC                              ;d6b0  c1          
    LD  A,(HL)                          ;d6b1  7e          ;was it an abort request?
    CP  CNTRLC                          ;d6b2  fe 03       ;control-c abort?
    LD  A,B                             ;d6b4  78          
    JP  NZ,RDBUF16                      ;d6b5  c2 bd d6    
    CP  1                               ;d6b8  fe 01       ;only if at start of line.
    JP  Z,0                             ;d6ba  ca 00 00    
RDBUF16:CP  C                           ;d6bd  b9          ;nope, have we filled the buffer?
    JP  C,RDBUF1                        ;d6be  da ef d5    
RDBUF17:POP HL                          ;d6c1  e1          ;yes end the line and return.
    LD  (HL),B                          ;d6c2  70          
    LD  C,CR                            ;d6c3  0e 0d       
    JP  OUTCHAR                         ;d6c5  c3 48 d5    ;output (cr) and return.
                  ;
                  ;   Function to get a character from the console device.
                  ;
GETCON: CALL    GETECHO                 ;d6c8  cd 06 d5    ;get and echo.
    JP  SETSTAT                         ;d6cb  c3 01 d7    ;save status and return.
                  ;
                  ;   Function to get a character from the tape reader device.
                  ;
GETRDR: CALL    READER                  ;d6ce  cd 15 e2    ;get a character from reader, set status and return.
    JP  SETSTAT                         ;d6d1  c3 01 d7    
                  ;
                  ;  Function to perform direct console i/o. If (C) contains (FF)
                  ; then this is an input request. If (C) contains (FE) then
                  ; this is a status request. Otherwise we are to output (C).
                  ;
DIRCIO: LD  A,C                         ;d6d4  79          ;test for (FF).
    INC A                               ;d6d5  3c          
    JP  Z,DIRC1                         ;d6d6  ca e0 d6    
    INC A                               ;d6d9  3c          ;test for (FE).
    JP  Z,CONST                         ;d6da  ca 06 e2    
    JP  CONOUT                          ;d6dd  c3 0c e2    ;just output (C).
DIRC1:  CALL    CONST                   ;d6e0  cd 06 e2    ;this is an input request.
    OR  A                               ;d6e3  b7          
    JP  Z,GOBACK1                       ;d6e4  ca 91 e1    ;not ready? Just return (directly).
    CALL    CONIN                       ;d6e7  cd 09 e2    ;yes, get character.
    JP  SETSTAT                         ;d6ea  c3 01 d7    ;set status and return.
                  ;
                  ;   Function to return the i/o byte.
                  ;
GETIOB: LD  A,(IOBYTE)                  ;d6ed  3a 03 00    
    JP  SETSTAT                         ;d6f0  c3 01 d7    
                  ;
                  ;   Function to set the i/o byte.
                  ;
SETIOB: LD  HL,IOBYTE                   ;d6f3  21 03 00    
    LD  (HL),C                          ;d6f6  71          
    RET                                 ;d6f7  c9          
                  ;
                  ;   Function to print the character string pointed to by (DE)
                  ; on the console device. The string ends with a '$'.
                  ;
PRTSTR: EX  DE,HL                       ;d6f8  eb          
    LD  C,L                             ;d6f9  4d          
    LD  B,H                             ;d6fa  44          ;now (BC) points to it.
    JP  PRTMESG                         ;d6fb  c3 d3 d5    
                  ;
                  ;   Function to interigate the console device.
                  ;
GETCSTS:CALL    CKCONSOL                ;d6fe  cd 23 d5    
                  ;
                  ;   Get here to set the status and return to the cleanup
                  ; section. Then back to the user.
                  ;
SETSTAT:LD  (STATUS),A                  ;d701  32 45 d7    
RTN:    RET                             ;d704  c9          
                  ;
                  ;   Set the status to 1 (read or write error code).
                  ;
IOERR1: LD  A,1                         ;d705  3e 01       
    JP  SETSTAT                         ;d707  c3 01 d7    
                  ;
OUTFLAG:DEFB    0                       ;d70a  00          ;output flag (non zero means no output).
STARTING: DEFB  2                       ;d70b  02          ;starting position for cursor.
CURPOS: DEFB    0                       ;d70c  00          ;cursor position (0=start of line).
PRTFLAG:DEFB    0                       ;d70d  00          ;printer flag (control-p toggle). List if non zero.
CHARBUF:DEFB    0                       ;d70e  00          ;single input character buffer.
                  ;
                  ;   Stack area for BDOS calls.
                  ;
USRSTACK: DEFW  0                       ;d70f  00 00       ;save users stack pointer here.
                  ;
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;d711  00 00 00 00 
                                        ;d715  00 00 00 00   1694   1781
                                        ;d719  00 00 00 00   1694   1782
                                        ;d71d  00 00 00 00   1694   1783
                                        ;d721  00 00 00 00   1694   1784
                                        ;d725  00 00 00 00   1694   1785
    DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;d729  00 00 00 00 
                                        ;d72d  00 00 00 00   1695   1787
                                        ;d731  00 00 00 00   1695   1788
                                        ;d735  00 00 00 00   1695   1789
                                        ;d739  00 00 00 00   1695   1790
                                        ;d73d  00 00 00 00   1695   1791
STKAREA EQU $                           ;d741              ;end of stack area.
                  ;
USERNO: DEFB    0                       ;d741  00          ;current user number.
ACTIVE: DEFB    0                       ;d742  00          ;currently active drive.
PARAMS: DEFW    0                       ;d743  00 00       ;save (DE) parameters here on entry.
STATUS: DEFW    0                       ;d745  00 00       ;status returned from bdos function.
                  ;
                  ;   Select error occured, jump to error routine.
                  ;
SLCTERR:LD  HL,BADSLCT                  ;d747  21 0b d4    
                  ;
                  ;   Jump to (HL) indirectly.
                  ;
JUMPHL: LD  E,(HL)                      ;d74a  5e          
    INC HL                              ;d74b  23          
    LD  D,(HL)                          ;d74c  56          ;now (DE) contain the desired address.
    EX  DE,HL                           ;d74d  eb          
    JP  (HL)                            ;d74e  e9          
                  ;
                  ;   Block move. (DE) to (HL), (C) bytes total.
                  ;
DE2HL:  INC C                           ;d74f  0c          ;is count down to zero?
DE2HL1: DEC C                           ;d750  0d          
    RET Z                               ;d751  c8          ;yes, we are done.
    LD  A,(DE)                          ;d752  1a          ;no, move one more byte.
    LD  (HL),A                          ;d753  77          
    INC DE                              ;d754  13          
    INC HL                              ;d755  23          
    JP  DE2HL1                          ;d756  c3 50 d7    ;and repeat.
                  ;
                  ;   Select the desired drive.
                  ;
SELECT: LD  A,(ACTIVE)                  ;d759  3a 42 d7    ;get active disk.
    LD  C,A                             ;d75c  4f          
    CALL    SELDSK                      ;d75d  cd 1b e2    ;select it.
    LD  A,H                             ;d760  7c          ;valid drive?
    OR  L                               ;d761  b5          ;valid drive?
    RET Z                               ;d762  c8          ;return if not.
                  ;
                  ;   Here, the BIOS returned the address of the parameter block
                  ; in (HL). We will extract the necessary pointers and save them.
                  ;
    LD  E,(HL)                          ;d763  5e          ;yes, get address of translation table into (DE).
    INC HL                              ;d764  23          
    LD  D,(HL)                          ;d765  56          
    INC HL                              ;d766  23          
    LD  (SCRATCH1),HL                   ;d767  22 b3 e1    ;save pointers to scratch areas.
    INC HL                              ;d76a  23          
    INC HL                              ;d76b  23          
    LD  (SCRATCH2),HL                   ;d76c  22 b5 e1    ;ditto.
    INC HL                              ;d76f  23          
    INC HL                              ;d770  23          
    LD  (SCRATCH3),HL                   ;d771  22 b7 e1    ;ditto.
    INC HL                              ;d774  23          
    INC HL                              ;d775  23          
    EX  DE,HL                           ;d776  eb          ;now save the translation table address.
    LD  (XLATE),HL                      ;d777  22 d0 e1    
    LD  HL,DIRBUF                       ;d77a  21 b9 e1    ;put the next 8 bytes here.
    LD  C,8                             ;d77d  0e 08       ;they consist of the directory buffer
    CALL    DE2HL                       ;d77f  cd 4f d7    ;pointer, parameter block pointer,
    LD  HL,(DISKPB)                     ;d782  2a bb e1    ;check and allocation vectors.
    EX  DE,HL                           ;d785  eb          
    LD  HL,SECTORS                      ;d786  21 c1 e1    ;move parameter block into our ram.
    LD  C,15                            ;d789  0e 0f       ;it is 15 bytes long.
    CALL    DE2HL                       ;d78b  cd 4f d7    
    LD  HL,(DSKSIZE)                    ;d78e  2a c6 e1    ;check disk size.
    LD  A,H                             ;d791  7c          ;more than 256 blocks on this?
    LD  HL,BIGDISK                      ;d792  21 dd e1    
    LD  (HL),0FFH                       ;d795  36 ff       ;set to samll.
    OR  A                               ;d797  b7          
    JP  Z,SELECT1                       ;d798  ca 9d d7    
    LD  (HL),0                          ;d79b  36 00       ;wrong, set to large.
SELECT1:LD  A,0FFH                      ;d79d  3e ff       ;clear the zero flag.
    OR  A                               ;d79f  b7          
    RET                                 ;d7a0  c9          
                  ;
                  ;   Routine to home the disk track head and clear pointers.
                  ;
HOMEDRV:CALL    HOME                    ;d7a1  cd 18 e2    ;home the head.
    XOR A                               ;d7a4  af          
    LD  HL,(SCRATCH2)                   ;d7a5  2a b5 e1    ;set our track pointer also.
    LD  (HL),A                          ;d7a8  77          
    INC HL                              ;d7a9  23          
    LD  (HL),A                          ;d7aa  77          
    LD  HL,(SCRATCH3)                   ;d7ab  2a b7 e1    ;and our sector pointer.
    LD  (HL),A                          ;d7ae  77          
    INC HL                              ;d7af  23          
    LD  (HL),A                          ;d7b0  77          
    RET                                 ;d7b1  c9          
                  ;
                  ;   Do the actual disk read and check the error return status.
                  ;
DOREAD: CALL    READ                    ;d7b2  cd 27 e2    
    JP  IORET                           ;d7b5  c3 bb d7    
                  ;
                  ;   Do the actual disk write and handle any bios error.
                  ;
DOWRITE:CALL    WRITE                   ;d7b8  cd 2a e2    
IORET:  OR  A                           ;d7bb  b7          
    RET Z                               ;d7bc  c8          ;return unless an error occured.
    LD  HL,BADSCTR                      ;d7bd  21 09 d4    ;bad read/write on this sector.
    JP  JUMPHL                          ;d7c0  c3 4a d7    
                  ;
                  ;   Routine to select the track and sector that the desired
                  ; block number falls in.
                  ;
TRKSEC: LD  HL,(FILEPOS)                ;d7c3  2a ea e1    ;get position of last accessed file
    LD  C,2                             ;d7c6  0e 02       ;in directory and compute sector #.
    CALL    SHIFTR                      ;d7c8  cd ea d8    ;sector #=file-position/4.
    LD  (BLKNMBR),HL                    ;d7cb  22 e5 e1    ;save this as the block number of interest.
    LD  (CKSUMTBL),HL                   ;d7ce  22 ec e1    ;what's it doing here too?
                  ;
                  ;   if the sector number has already been set (BLKNMBR), enter
                  ; at this point.
                  ;
TRKSEC1:LD  HL,BLKNMBR                  ;d7d1  21 e5 e1    
    LD  C,(HL)                          ;d7d4  4e          ;move sector number into (BC).
    INC HL                              ;d7d5  23          
    LD  B,(HL)                          ;d7d6  46          
    LD  HL,(SCRATCH3)                   ;d7d7  2a b7 e1    ;get current sector number and
    LD  E,(HL)                          ;d7da  5e          ;move this into (DE).
    INC HL                              ;d7db  23          
    LD  D,(HL)                          ;d7dc  56          
    LD  HL,(SCRATCH2)                   ;d7dd  2a b5 e1    ;get current track number.
    LD  A,(HL)                          ;d7e0  7e          ;and this into (HL).
    INC HL                              ;d7e1  23          
    LD  H,(HL)                          ;d7e2  66          
    LD  L,A                             ;d7e3  6f          
TRKSEC2:LD  A,C                         ;d7e4  79          ;is desired sector before current one?
    SUB E                               ;d7e5  93          
    LD  A,B                             ;d7e6  78          
    SBC A,D                             ;d7e7  9a          
    JP  NC,TRKSEC3                      ;d7e8  d2 fa d7    
    PUSH    HL                          ;d7eb  e5          ;yes, decrement sectors by one track.
    LD  HL,(SECTORS)                    ;d7ec  2a c1 e1    ;get sectors per track.
    LD  A,E                             ;d7ef  7b          
    SUB L                               ;d7f0  95          
    LD  E,A                             ;d7f1  5f          
    LD  A,D                             ;d7f2  7a          
    SBC A,H                             ;d7f3  9c          
    LD  D,A                             ;d7f4  57          ;now we have backed up one full track.
    POP HL                              ;d7f5  e1          
    DEC HL                              ;d7f6  2b          ;adjust track counter.
    JP  TRKSEC2                         ;d7f7  c3 e4 d7    
TRKSEC3:PUSH    HL                      ;d7fa  e5          ;desired sector is after current one.
    LD  HL,(SECTORS)                    ;d7fb  2a c1 e1    ;get sectors per track.
    ADD HL,DE                           ;d7fe  19          ;bump sector pointer to next track.
    JP  C,TRKSEC4                       ;d7ff  da 0f d8    
    LD  A,C                             ;d802  79          ;is desired sector now before current one?
    SUB L                               ;d803  95          
    LD  A,B                             ;d804  78          
    SBC A,H                             ;d805  9c          
    JP  C,TRKSEC4                       ;d806  da 0f d8    
    EX  DE,HL                           ;d809  eb          ;not yes, increment track counter
    POP HL                              ;d80a  e1          ;and continue until it is.
    INC HL                              ;d80b  23          
    JP  TRKSEC3                         ;d80c  c3 fa d7    
                  ;
                  ;   here we have determined the track number that contains the
                  ; desired sector.
                  ;
TRKSEC4:POP HL                          ;d80f  e1          ;get track number (HL).
    PUSH    BC                          ;d810  c5          
    PUSH    DE                          ;d811  d5          
    PUSH    HL                          ;d812  e5          
    EX  DE,HL                           ;d813  eb          
    LD  HL,(OFFSET)                     ;d814  2a ce e1    ;adjust for first track offset.
    ADD HL,DE                           ;d817  19          
    LD  B,H                             ;d818  44          
    LD  C,L                             ;d819  4d          
    CALL    SETTRK                      ;d81a  cd 1e e2    ;select this track.
    POP DE                              ;d81d  d1          ;reset current track pointer.
    LD  HL,(SCRATCH2)                   ;d81e  2a b5 e1    
    LD  (HL),E                          ;d821  73          
    INC HL                              ;d822  23          
    LD  (HL),D                          ;d823  72          
    POP DE                              ;d824  d1          
    LD  HL,(SCRATCH3)                   ;d825  2a b7 e1    ;reset the first sector on this track.
    LD  (HL),E                          ;d828  73          
    INC HL                              ;d829  23          
    LD  (HL),D                          ;d82a  72          
    POP BC                              ;d82b  c1          
    LD  A,C                             ;d82c  79          ;now subtract the desired one.
    SUB E                               ;d82d  93          ;to make it relative (1-# sectors/track).
    LD  C,A                             ;d82e  4f          
    LD  A,B                             ;d82f  78          
    SBC A,D                             ;d830  9a          
    LD  B,A                             ;d831  47          
    LD  HL,(XLATE)                      ;d832  2a d0 e1    ;translate this sector according to this table.
    EX  DE,HL                           ;d835  eb          
    CALL    SECTRN                      ;d836  cd 30 e2    ;let the bios translate it.
    LD  C,L                             ;d839  4d          
    LD  B,H                             ;d83a  44          
    JP  SETSEC                          ;d83b  c3 21 e2    ;and select it.
                  ;
                  ;   Compute block number from record number (SAVNREC) and
                  ; extent number (SAVEXT).
                  ;
GETBLOCK: LD    HL,BLKSHFT              ;d83e  21 c3 e1    ;get logical to physical conversion.
    LD  C,(HL)                          ;d841  4e          ;note that this is base 2 log of ratio.
    LD  A,(SAVNREC)                     ;d842  3a e3 e1    ;get record number.
GETBLK1:OR  A                           ;d845  b7          ;compute (A)=(A)/2^BLKSHFT.
    RRA                                 ;d846  1f          
    DEC C                               ;d847  0d          
    JP  NZ,GETBLK1                      ;d848  c2 45 d8    
    LD  B,A                             ;d84b  47          ;save result in (B).
    LD  A,8                             ;d84c  3e 08       
    SUB (HL)                            ;d84e  96          
    LD  C,A                             ;d84f  4f          ;compute (C)=8-BLKSHFT.
    LD  A,(SAVEXT)                      ;d850  3a e2 e1    
GETBLK2:DEC C                           ;d853  0d          ;compute (A)=SAVEXT*2^(8-BLKSHFT).
    JP  Z,GETBLK3                       ;d854  ca 5c d8    
    OR  A                               ;d857  b7          
    RLA                                 ;d858  17          
    JP  GETBLK2                         ;d859  c3 53 d8    
GETBLK3:ADD A,B                         ;d85c  80          
    RET                                 ;d85d  c9          
                  ;
                  ;   Routine to extract the (BC) block byte from the fcb pointed
                  ; to by (PARAMS). If this is a big-disk, then these are 16 bit
                  ; block numbers, else they are 8 bit numbers.
                  ; Number is returned in (HL).
                  ;
EXTBLK: LD  HL,(PARAMS)                 ;d85e  2a 43 d7    ;get fcb address.
    LD  DE,16                           ;d861  11 10 00    ;block numbers start 16 bytes into fcb.
    ADD HL,DE                           ;d864  19          
    ADD HL,BC                           ;d865  09          
    LD  A,(BIGDISK)                     ;d866  3a dd e1    ;are we using a big-disk?
    OR  A                               ;d869  b7          
    JP  Z,EXTBLK1                       ;d86a  ca 71 d8    
    LD  L,(HL)                          ;d86d  6e          ;no, extract an 8 bit number from the fcb.
    LD  H,0                             ;d86e  26 00       
    RET                                 ;d870  c9          
EXTBLK1:ADD HL,BC                       ;d871  09          ;yes, extract a 16 bit number.
    LD  E,(HL)                          ;d872  5e          
    INC HL                              ;d873  23          
    LD  D,(HL)                          ;d874  56          
    EX  DE,HL                           ;d875  eb          ;return in (HL).
    RET                                 ;d876  c9          
                  ;
                  ;   Compute block number.
                  ;
COMBLK: CALL    GETBLOCK                ;d877  cd 3e d8    
    LD  C,A                             ;d87a  4f          
    LD  B,0                             ;d87b  06 00       
    CALL    EXTBLK                      ;d87d  cd 5e d8    
    LD  (BLKNMBR),HL                    ;d880  22 e5 e1    
    RET                                 ;d883  c9          
                  ;
                  ;   Check for a zero block number (unused).
                  ;
CHKBLK: LD  HL,(BLKNMBR)                ;d884  2a e5 e1    
    LD  A,L                             ;d887  7d          ;is it zero?
    OR  H                               ;d888  b4          
    RET                                 ;d889  c9          
                  ;
                  ;   Adjust physical block (BLKNMBR) and convert to logical
                  ; sector (LOGSECT). This is the starting sector of this block.
                  ; The actual sector of interest is then added to this and the
                  ; resulting sector number is stored back in (BLKNMBR). This
                  ; will still have to be adjusted for the track number.
                  ;
LOGICAL:LD  A,(BLKSHFT)                 ;d88a  3a c3 e1    ;get log2(physical/logical sectors).
    LD  HL,(BLKNMBR)                    ;d88d  2a e5 e1    ;get physical sector desired.
LOGICL1:ADD HL,HL                       ;d890  29          ;compute logical sector number.
    DEC A                               ;d891  3d          ;note logical sectors are 128 bytes long.
    JP  NZ,LOGICL1                      ;d892  c2 90 d8    
    LD  (LOGSECT),HL                    ;d895  22 e7 e1    ;save logical sector.
    LD  A,(BLKMASK)                     ;d898  3a c4 e1    ;get block mask.
    LD  C,A                             ;d89b  4f          
    LD  A,(SAVNREC)                     ;d89c  3a e3 e1    ;get next sector to access.
    AND C                               ;d89f  a1          ;extract the relative position within physical block.
    OR  L                               ;d8a0  b5          ;and add it too logical sector.
    LD  L,A                             ;d8a1  6f          
    LD  (BLKNMBR),HL                    ;d8a2  22 e5 e1    ;and store.
    RET                                 ;d8a5  c9          
                  ;
                  ;   Set (HL) to point to extent byte in fcb.
                  ;
SETEXT: LD  HL,(PARAMS)                 ;d8a6  2a 43 d7    
    LD  DE,12                           ;d8a9  11 0c 00    ;it is the twelth byte.
    ADD HL,DE                           ;d8ac  19          
    RET                                 ;d8ad  c9          
                  ;
                  ;   Set (HL) to point to record count byte in fcb and (DE) to
                  ; next record number byte.
                  ;
SETHLDE:LD  HL,(PARAMS)                 ;d8ae  2a 43 d7    
    LD  DE,15                           ;d8b1  11 0f 00    ;record count byte (#15).
    ADD HL,DE                           ;d8b4  19          
    EX  DE,HL                           ;d8b5  eb          
    LD  HL,17                           ;d8b6  21 11 00    ;next record number (#32).
    ADD HL,DE                           ;d8b9  19          
    RET                                 ;d8ba  c9          
                  ;
                  ;   Save current file data from fcb.
                  ;
STRDATA:CALL    SETHLDE                 ;d8bb  cd ae d8    
    LD  A,(HL)                          ;d8be  7e          ;get and store record count byte.
    LD  (SAVNREC),A                     ;d8bf  32 e3 e1    
    EX  DE,HL                           ;d8c2  eb          
    LD  A,(HL)                          ;d8c3  7e          ;get and store next record number byte.
    LD  (SAVNXT),A                      ;d8c4  32 e1 e1    
    CALL    SETEXT                      ;d8c7  cd a6 d8    ;point to extent byte.
    LD  A,(EXTMASK)                     ;d8ca  3a c5 e1    ;get extent mask.
    AND (HL)                            ;d8cd  a6          
    LD  (SAVEXT),A                      ;d8ce  32 e2 e1    ;and save extent here.
    RET                                 ;d8d1  c9          
                  ;
                  ;   Set the next record to access. If (MODE) is set to 2, then
                  ; the last record byte (SAVNREC) has the correct number to access.
                  ; For sequential access, (MODE) will be equal to 1.
                  ;
SETNREC:CALL    SETHLDE                 ;d8d2  cd ae d8    
    LD  A,(MODE)                        ;d8d5  3a d5 e1    ;get sequential flag (=1).
    CP  2                               ;d8d8  fe 02       ;a 2 indicates that no adder is needed.
    JP  NZ,STNREC1                      ;d8da  c2 de d8    
    XOR A                               ;d8dd  af          ;clear adder (random access?).
STNREC1:LD  C,A                         ;d8de  4f          
    LD  A,(SAVNREC)                     ;d8df  3a e3 e1    ;get last record number.
    ADD A,C                             ;d8e2  81          ;increment record count.
    LD  (HL),A                          ;d8e3  77          ;and set fcb's next record byte.
    EX  DE,HL                           ;d8e4  eb          
    LD  A,(SAVNXT)                      ;d8e5  3a e1 e1    ;get next record byte from storage.
    LD  (HL),A                          ;d8e8  77          ;and put this into fcb as number of records used.
    RET                                 ;d8e9  c9          
                  ;
                  ;   Shift (HL) right (C) bits.
                  ;
SHIFTR: INC C                           ;d8ea  0c          
SHIFTR1:DEC C                           ;d8eb  0d          
    RET Z                               ;d8ec  c8          
    LD  A,H                             ;d8ed  7c          
    OR  A                               ;d8ee  b7          
    RRA                                 ;d8ef  1f          
    LD  H,A                             ;d8f0  67          
    LD  A,L                             ;d8f1  7d          
    RRA                                 ;d8f2  1f          
    LD  L,A                             ;d8f3  6f          
    JP  SHIFTR1                         ;d8f4  c3 eb d8    
                  ;
                  ;   Compute the check-sum for the directory buffer. Return
                  ; integer sum in (A).
                  ;
CHECKSUM: LD    C,128                   ;d8f7  0e 80       ;length of buffer.
    LD  HL,(DIRBUF)                     ;d8f9  2a b9 e1    ;get its location.
    XOR A                               ;d8fc  af          ;clear summation byte.
CHKSUM1:ADD A,(HL)                      ;d8fd  86          ;and compute sum ignoring carries.
    INC HL                              ;d8fe  23          
    DEC C                               ;d8ff  0d          
    JP  NZ,CHKSUM1                      ;d900  c2 fd d8    
    RET                                 ;d903  c9          
                  ;
                  ;   Shift (HL) left (C) bits.
                  ;
SHIFTL: INC C                           ;d904  0c          
SHIFTL1:DEC C                           ;d905  0d          
    RET Z                               ;d906  c8          
    ADD HL,HL                           ;d907  29          ;shift left 1 bit.
    JP  SHIFTL1                         ;d908  c3 05 d9    
                  ;
                  ;   Routine to set a bit in a 16 bit value contained in (BC).
                  ; The bit set depends on the current drive selection.
                  ;
SETBIT: PUSH    BC                      ;d90b  c5          ;save 16 bit word.
    LD  A,(ACTIVE)                      ;d90c  3a 42 d7    ;get active drive.
    LD  C,A                             ;d90f  4f          
    LD  HL,1                            ;d910  21 01 00    
    CALL    SHIFTL                      ;d913  cd 04 d9    ;shift bit 0 into place.
    POP BC                              ;d916  c1          ;now 'or' this with the original word.
    LD  A,C                             ;d917  79          
    OR  L                               ;d918  b5          
    LD  L,A                             ;d919  6f          ;low byte done, do high byte.
    LD  A,B                             ;d91a  78          
    OR  H                               ;d91b  b4          
    LD  H,A                             ;d91c  67          
    RET                                 ;d91d  c9          
                  ;
                  ;   Extract the write protect status bit for the current drive.
                  ; The result is returned in (A), bit 0.
                  ;
GETWPRT:LD  HL,(WRTPRT)                 ;d91e  2a ad e1    ;get status bytes.
    LD  A,(ACTIVE)                      ;d921  3a 42 d7    ;which drive is current?
    LD  C,A                             ;d924  4f          
    CALL    SHIFTR                      ;d925  cd ea d8    ;shift status such that bit 0 is the
    LD  A,L                             ;d928  7d          ;one of interest for this drive.
    AND 01H                             ;d929  e6 01       ;and isolate it.
    RET                                 ;d92b  c9          
                  ;
                  ;   Function to write protect the current disk.
                  ;
WRTPRTD:LD  HL,WRTPRT                   ;d92c  21 ad e1    ;point to status word.
    LD  C,(HL)                          ;d92f  4e          ;set (BC) equal to the status.
    INC HL                              ;d930  23          
    LD  B,(HL)                          ;d931  46          
    CALL    SETBIT                      ;d932  cd 0b d9    ;and set this bit according to current drive.
    LD  (WRTPRT),HL                     ;d935  22 ad e1    ;then save.
    LD  HL,(DIRSIZE)                    ;d938  2a c8 e1    ;now save directory size limit.
    INC HL                              ;d93b  23          ;remember the last one.
    EX  DE,HL                           ;d93c  eb          
    LD  HL,(SCRATCH1)                   ;d93d  2a b3 e1    ;and store it here.
    LD  (HL),E                          ;d940  73          ;put low byte.
    INC HL                              ;d941  23          
    LD  (HL),D                          ;d942  72          ;then high byte.
    RET                                 ;d943  c9          
                  ;
                  ;   Check for a read only file.
                  ;
CHKROFL:CALL    FCB2HL                  ;d944  cd 5e d9    ;set (HL) to file entry in directory buffer.
CKROF1: LD  DE,9                        ;d947  11 09 00    ;look at bit 7 of the ninth byte.
    ADD HL,DE                           ;d94a  19          
    LD  A,(HL)                          ;d94b  7e          
    RLA                                 ;d94c  17          
    RET NC                              ;d94d  d0          ;return if ok.
    LD  HL,ROFILE                       ;d94e  21 0f d4    ;else, print error message and terminate.
    JP  JUMPHL                          ;d951  c3 4a d7    
                  ;
                  ;   Check the write protect status of the active disk.
                  ;
CHKWPRT:CALL    GETWPRT                 ;d954  cd 1e d9    
    RET Z                               ;d957  c8          ;return if ok.
    LD  HL,RODISK                       ;d958  21 0d d4    ;else print message and terminate.
    JP  JUMPHL                          ;d95b  c3 4a d7    
                  ;
                  ;   Routine to set (HL) pointing to the proper entry in the
                  ; directory buffer.
                  ;
FCB2HL: LD  HL,(DIRBUF)                 ;d95e  2a b9 e1    ;get address of buffer.
    LD  A,(FCBPOS)                      ;d961  3a e9 e1    ;relative position of file.
                  ;
                  ;   Routine to add (A) to (HL).
                  ;
ADDA2HL:ADD A,L                         ;d964  85          
    LD  L,A                             ;d965  6f          
    RET NC                              ;d966  d0          
    INC H                               ;d967  24          ;take care of any carry.
    RET                                 ;d968  c9          
                  ;
                  ;   Routine to get the 's2' byte from the fcb supplied in
                  ; the initial parameter specification.
                  ;
GETS2:  LD  HL,(PARAMS)                 ;d969  2a 43 d7    ;get address of fcb.
    LD  DE,14                           ;d96c  11 0e 00    ;relative position of 's2'.
    ADD HL,DE                           ;d96f  19          
    LD  A,(HL)                          ;d970  7e          ;extract this byte.
    RET                                 ;d971  c9          
                  ;
                  ;   Clear the 's2' byte in the fcb.
                  ;
CLEARS2:CALL    GETS2                   ;d972  cd 69 d9    ;this sets (HL) pointing to it.
    LD  (HL),0                          ;d975  36 00       ;now clear it.
    RET                                 ;d977  c9          
                  ;
                  ;   Set bit 7 in the 's2' byte of the fcb.
                  ;
SETS2B7:CALL    GETS2                   ;d978  cd 69 d9    ;get the byte.
    OR  80H                             ;d97b  f6 80       ;and set bit 7.
    LD  (HL),A                          ;d97d  77          ;then store.
    RET                                 ;d97e  c9          
                  ;
                  ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
                  ; the difference. This checks to see if there are more file
                  ; names in the directory. We are at (FILEPOS) and there are
                  ; (SCRATCH1) of them to check.
                  ;
MOREFLS:LD  HL,(FILEPOS)                ;d97f  2a ea e1    ;we are here.
    EX  DE,HL                           ;d982  eb          
    LD  HL,(SCRATCH1)                   ;d983  2a b3 e1    ;and don't go past here.
    LD  A,E                             ;d986  7b          ;compute difference but don't keep.
    SUB (HL)                            ;d987  96          
    INC HL                              ;d988  23          
    LD  A,D                             ;d989  7a          
    SBC A,(HL)                          ;d98a  9e          ;set carry if no more names.
    RET                                 ;d98b  c9          
                  ;
                  ;   Call this routine to prevent (SCRATCH1) from being greater
                  ; than (FILEPOS).
                  ;
CHKNMBR:CALL    MOREFLS                 ;d98c  cd 7f d9    ;SCRATCH1 too big?
    RET C                               ;d98f  d8          
    INC DE                              ;d990  13          ;yes, reset it to (FILEPOS).
    LD  (HL),D                          ;d991  72          
    DEC HL                              ;d992  2b          
    LD  (HL),E                          ;d993  73          
    RET                                 ;d994  c9          
                  ;
                  ;   Compute (HL)=(DE)-(HL)
                  ;
SUBHL:  LD  A,E                         ;d995  7b          ;compute difference.
    SUB L                               ;d996  95          
    LD  L,A                             ;d997  6f          ;store low byte.
    LD  A,D                             ;d998  7a          
    SBC A,H                             ;d999  9c          
    LD  H,A                             ;d99a  67          ;and then high byte.
    RET                                 ;d99b  c9          
                  ;
                  ;   Set the directory checksum byte.
                  ;
SETDIR: LD  C,0FFH                      ;d99c  0e ff       
                  ;
                  ;   Routine to set or compare the directory checksum byte. If
                  ; (C)=0ffh, then this will set the checksum byte. Else the byte
                  ; will be checked. If the check fails (the disk has been changed),
                  ; then this disk will be write protected.
                  ;
CHECKDIR: LD    HL,(CKSUMTBL)           ;d99e  2a ec e1    
    EX  DE,HL                           ;d9a1  eb          
    LD  HL,(ALLOC1)                     ;d9a2  2a cc e1    
    CALL    SUBHL                       ;d9a5  cd 95 d9    
    RET NC                              ;d9a8  d0          ;ok if (CKSUMTBL) > (ALLOC1), so return.
    PUSH    BC                          ;d9a9  c5          
    CALL    CHECKSUM                    ;d9aa  cd f7 d8    ;else compute checksum.
    LD  HL,(CHKVECT)                    ;d9ad  2a bd e1    ;get address of checksum table.
    EX  DE,HL                           ;d9b0  eb          
    LD  HL,(CKSUMTBL)                   ;d9b1  2a ec e1    
    ADD HL,DE                           ;d9b4  19          ;set (HL) to point to byte for this drive.
    POP BC                              ;d9b5  c1          
    INC C                               ;d9b6  0c          ;set or check ?
    JP  Z,CHKDIR1                       ;d9b7  ca c4 d9    
    CP  (HL)                            ;d9ba  be          ;check them.
    RET Z                               ;d9bb  c8          ;return if they are the same.
    CALL    MOREFLS                     ;d9bc  cd 7f d9    ;not the same, do we care?
    RET NC                              ;d9bf  d0          
    CALL    WRTPRTD                     ;d9c0  cd 2c d9    ;yes, mark this as write protected.
    RET                                 ;d9c3  c9          
CHKDIR1:LD  (HL),A                      ;d9c4  77          ;just set the byte.
    RET                                 ;d9c5  c9          
                  ;
                  ;   Do a write to the directory of the current disk.
                  ;
DIRWRITE: CALL  SETDIR                  ;d9c6  cd 9c d9    ;set checksum byte.
    CALL    DIRDMA                      ;d9c9  cd e0 d9    ;set directory dma address.
    LD  C,1                             ;d9cc  0e 01       ;tell the bios to actually write.
    CALL    DOWRITE                     ;d9ce  cd b8 d7    ;then do the write.
    JP  DEFDMA                          ;d9d1  c3 da d9    
                  ;
                  ;   Read from the directory.
                  ;
DIRREAD:CALL    DIRDMA                  ;d9d4  cd e0 d9    ;set the directory dma address.
    CALL    DOREAD                      ;d9d7  cd b2 d7    ;and read it.
                  ;
                  ;   Routine to set the dma address to the users choice.
                  ;
DEFDMA: LD  HL,USERDMA                  ;d9da  21 b1 e1    ;reset the default dma address and return.
    JP  DIRDMA1                         ;d9dd  c3 e3 d9    
                  ;
                  ;   Routine to set the dma address for directory work.
                  ;
DIRDMA: LD  HL,DIRBUF                   ;d9e0  21 b9 e1    
                  ;
                  ;   Set the dma address. On entry, (HL) points to
                  ; word containing the desired dma address.
                  ;
DIRDMA1:LD  C,(HL)                      ;d9e3  4e          
    INC HL                              ;d9e4  23          
    LD  B,(HL)                          ;d9e5  46          ;setup (BC) and go to the bios to set it.
    JP  SETDMA                          ;d9e6  c3 24 e2    
                  ;
                  ;   Move the directory buffer into user's dma space.
                  ;
MOVEDIR:LD  HL,(DIRBUF)                 ;d9e9  2a b9 e1    ;buffer is located here, and
    EX  DE,HL                           ;d9ec  eb          
    LD  HL,(USERDMA)                    ;d9ed  2a b1 e1    ; put it here.
    LD  C,128                           ;d9f0  0e 80       ;this is its length.
    JP  DE2HL                           ;d9f2  c3 4f d7    ;move it now and return.
                  ;
                  ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
                  ;
CKFILPOS: LD    HL,FILEPOS              ;d9f5  21 ea e1    
    LD  A,(HL)                          ;d9f8  7e          
    INC HL                              ;d9f9  23          
    CP  (HL)                            ;d9fa  be          ;are both bytes the same?
    RET NZ                              ;d9fb  c0          
    INC A                               ;d9fc  3c          ;yes, but are they each 0ffh?
    RET                                 ;d9fd  c9          
                  ;
                  ;   Set location (FILEPOS) to 0ffffh.
                  ;
STFILPOS: LD    HL,0FFFFH               ;d9fe  21 ff ff    
    LD  (FILEPOS),HL                    ;da01  22 ea e1    
    RET                                 ;da04  c9          
                  ;
                  ;   Move on to the next file position within the current
                  ; directory buffer. If no more exist, set pointer to 0ffffh
                  ; and the calling routine will check for this. Enter with (C)
                  ; equal to 0ffh to cause the checksum byte to be set, else we
                  ; will check this disk and set write protect if checksums are
                  ; not the same (applies only if another directory sector must
                  ; be read).
                  ;
NXENTRY:LD  HL,(DIRSIZE)                ;da05  2a c8 e1    ;get directory entry size limit.
    EX  DE,HL                           ;da08  eb          
    LD  HL,(FILEPOS)                    ;da09  2a ea e1    ;get current count.
    INC HL                              ;da0c  23          ;go on to the next one.
    LD  (FILEPOS),HL                    ;da0d  22 ea e1    
    CALL    SUBHL                       ;da10  cd 95 d9    ;(HL)=(DIRSIZE)-(FILEPOS)
    JP  NC,NXENT1                       ;da13  d2 19 da    ;is there more room left?
    JP  STFILPOS                        ;da16  c3 fe d9    ;no. Set this flag and return.
NXENT1: LD  A,(FILEPOS)                 ;da19  3a ea e1    ;get file position within directory.
    AND 03H                             ;da1c  e6 03       ;only look within this sector (only 4 entries fit).
    LD  B,5                             ;da1e  06 05       ;convert to relative position (32 bytes each).
NXENT2: ADD A,A                         ;da20  87          ;note that this is not efficient code.
    DEC B                               ;da21  05          ;5 'ADD A's would be better.
    JP  NZ,NXENT2                       ;da22  c2 20 da    
    LD  (FCBPOS),A                      ;da25  32 e9 e1    ;save it as position of fcb.
    OR  A                               ;da28  b7          
    RET NZ                              ;da29  c0          ;return if we are within buffer.
    PUSH    BC                          ;da2a  c5          
    CALL    TRKSEC                      ;da2b  cd c3 d7    ;we need the next directory sector.
    CALL    DIRREAD                     ;da2e  cd d4 d9    
    POP BC                              ;da31  c1          
    JP  CHECKDIR                        ;da32  c3 9e d9    
                  ;
                  ;   Routine to to get a bit from the disk space allocation
                  ; map. It is returned in (A), bit position 0. On entry to here,
                  ; set (BC) to the block number on the disk to check.
                  ; On return, (D) will contain the original bit position for
                  ; this block number and (HL) will point to the address for it.
                  ;
CKBITMAP: LD    A,C                     ;da35  79          ;determine bit number of interest.
    AND 07H                             ;da36  e6 07       ;compute (D)=(E)=(C and 7)+1.
    INC A                               ;da38  3c          
    LD  E,A                             ;da39  5f          ;save particular bit number.
    LD  D,A                             ;da3a  57          
                  ;
                  ;   compute (BC)=(BC)/8.
                  ;
    LD  A,C                             ;da3b  79          
    RRCA                                ;da3c  0f          ;now shift right 3 bits.
    RRCA                                ;da3d  0f          
    RRCA                                ;da3e  0f          
    AND 1FH                             ;da3f  e6 1f       ;and clear bits 7,6,5.
    LD  C,A                             ;da41  4f          
    LD  A,B                             ;da42  78          
    ADD A,A                             ;da43  87          ;now shift (B) into bits 7,6,5.
    ADD A,A                             ;da44  87          
    ADD A,A                             ;da45  87          
    ADD A,A                             ;da46  87          
    ADD A,A                             ;da47  87          
    OR  C                               ;da48  b1          ;and add in (C).
    LD  C,A                             ;da49  4f          ;ok, (C) ha been completed.
    LD  A,B                             ;da4a  78          ;is there a better way of doing this?
    RRCA                                ;da4b  0f          
    RRCA                                ;da4c  0f          
    RRCA                                ;da4d  0f          
    AND 1FH                             ;da4e  e6 1f       
    LD  B,A                             ;da50  47          ;and now (B) is completed.
                  ;
                  ;   use this as an offset into the disk space allocation
                  ; table.
                  ;
    LD  HL,(ALOCVECT)                   ;da51  2a bf e1    
    ADD HL,BC                           ;da54  09          
    LD  A,(HL)                          ;da55  7e          ;now get correct byte.
CKBMAP1:RLCA                            ;da56  07          ;get correct bit into position 0.
    DEC E                               ;da57  1d          
    JP  NZ,CKBMAP1                      ;da58  c2 56 da    
    RET                                 ;da5b  c9          
                  ;
                  ;   Set or clear the bit map such that block number (BC) will be marked
                  ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
                  ; 1 then it will be set (don't use anyother values).
                  ;
STBITMAP: PUSH  DE                      ;da5c  d5          
    CALL    CKBITMAP                    ;da5d  cd 35 da    ;get the byte of interest.
    AND 0FEH                            ;da60  e6 fe       ;clear the affected bit.
    POP BC                              ;da62  c1          
    OR  C                               ;da63  b1          ;and now set it acording to (C).
                  ;
                  ;  entry to restore the original bit position and then store
                  ; in table. (A) contains the value, (D) contains the bit
                  ; position (1-8), and (HL) points to the address within the
                  ; space allocation table for this byte.
                  ;
STBMAP1:RRCA                            ;da64  0f          ;restore original bit position.
    DEC D                               ;da65  15          
    JP  NZ,STBMAP1                      ;da66  c2 64 da    
    LD  (HL),A                          ;da69  77          ;and stor byte in table.
    RET                                 ;da6a  c9          
                  ;
                  ;   Set/clear space used bits in allocation map for this file.
                  ; On entry, (C)=1 to set the map and (C)=0 to clear it.
                  ;
SETFILE:CALL    FCB2HL                  ;da6b  cd 5e d9    ;get address of fcb
    LD  DE,16                           ;da6e  11 10 00    
    ADD HL,DE                           ;da71  19          ;get to block number bytes.
    PUSH    BC                          ;da72  c5          
    LD  C,17                            ;da73  0e 11       ;check all 17 bytes (max) of table.
SETFL1: POP DE                          ;da75  d1          
    DEC C                               ;da76  0d          ;done all bytes yet?
    RET Z                               ;da77  c8          
    PUSH    DE                          ;da78  d5          
    LD  A,(BIGDISK)                     ;da79  3a dd e1    ;check disk size for 16 bit block numbers.
    OR  A                               ;da7c  b7          
    JP  Z,SETFL2                        ;da7d  ca 88 da    
    PUSH    BC                          ;da80  c5          ;only 8 bit numbers. set (BC) to this one.
    PUSH    HL                          ;da81  e5          
    LD  C,(HL)                          ;da82  4e          ;get low byte from table, always
    LD  B,0                             ;da83  06 00       ;set high byte to zero.
    JP  SETFL3                          ;da85  c3 8e da    
SETFL2: DEC C                           ;da88  0d          ;for 16 bit block numbers, adjust counter.
    PUSH    BC                          ;da89  c5          
    LD  C,(HL)                          ;da8a  4e          ;now get both the low and high bytes.
    INC HL                              ;da8b  23          
    LD  B,(HL)                          ;da8c  46          
    PUSH    HL                          ;da8d  e5          
SETFL3: LD  A,C                         ;da8e  79          ;block used?
    OR  B                               ;da8f  b0          
    JP  Z,SETFL4                        ;da90  ca 9d da    
    LD  HL,(DSKSIZE)                    ;da93  2a c6 e1    ;is this block number within the
    LD  A,L                             ;da96  7d          ;space on the disk?
    SUB C                               ;da97  91          
    LD  A,H                             ;da98  7c          
    SBC A,B                             ;da99  98          
    CALL    NC,STBITMAP                 ;da9a  d4 5c da    ;yes, set the proper bit.
SETFL4: POP HL                          ;da9d  e1          ;point to next block number in fcb.
    INC HL                              ;da9e  23          
    POP BC                              ;da9f  c1          
    JP  SETFL1                          ;daa0  c3 75 da    
                  ;
                  ;   Construct the space used allocation bit map for the active
                  ; drive. If a file name starts with '$' and it is under the
                  ; current user number, then (STATUS) is set to minus 1. Otherwise
                  ; it is not set at all.
                  ;
BITMAP: LD  HL,(DSKSIZE)                ;daa3  2a c6 e1    ;compute size of allocation table.
    LD  C,3                             ;daa6  0e 03       
    CALL    SHIFTR                      ;daa8  cd ea d8    ;(HL)=(HL)/8.
    INC HL                              ;daab  23          ;at lease 1 byte.
    LD  B,H                             ;daac  44          
    LD  C,L                             ;daad  4d          ;set (BC) to the allocation table length.
                  ;
                  ;   Initialize the bitmap for this drive. Right now, the first
                  ; two bytes are specified by the disk parameter block. However
                  ; a patch could be entered here if it were necessary to setup
                  ; this table in a special mannor. For example, the bios could
                  ; determine locations of 'bad blocks' and set them as already
                  ; 'used' in the map.
                  ;
    LD  HL,(ALOCVECT)                   ;daae  2a bf e1    ;now zero out the table now.
BITMAP1:LD  (HL),0                      ;dab1  36 00       
    INC HL                              ;dab3  23          
    DEC BC                              ;dab4  0b          
    LD  A,B                             ;dab5  78          
    OR  C                               ;dab6  b1          
    JP  NZ,BITMAP1                      ;dab7  c2 b1 da    
    LD  HL,(ALLOC0)                     ;daba  2a ca e1    ;get initial space used by directory.
    EX  DE,HL                           ;dabd  eb          
    LD  HL,(ALOCVECT)                   ;dabe  2a bf e1    ;and put this into map.
    LD  (HL),E                          ;dac1  73          
    INC HL                              ;dac2  23          
    LD  (HL),D                          ;dac3  72          
                  ;
                  ;   End of initialization portion.
                  ;
    CALL    HOMEDRV                     ;dac4  cd a1 d7    ;now home the drive.
    LD  HL,(SCRATCH1)                   ;dac7  2a b3 e1    
    LD  (HL),3                          ;daca  36 03       ;force next directory request to read
    INC HL                              ;dacc  23          ;in a sector.
    LD  (HL),0                          ;dacd  36 00       
    CALL    STFILPOS                    ;dacf  cd fe d9    ;clear initial file position also.
BITMAP2:LD  C,0FFH                      ;dad2  0e ff       ;read next file name in directory
    CALL    NXENTRY                     ;dad4  cd 05 da    ;and set checksum byte.
    CALL    CKFILPOS                    ;dad7  cd f5 d9    ;is there another file?
    RET Z                               ;dada  c8          
    CALL    FCB2HL                      ;dadb  cd 5e d9    ;yes, get its address.
    LD  A,0E5H                          ;dade  3e e5       
    CP  (HL)                            ;dae0  be          ;empty file entry?
    JP  Z,BITMAP2                       ;dae1  ca d2 da    
    LD  A,(USERNO)                      ;dae4  3a 41 d7    ;no, correct user number?
    CP  (HL)                            ;dae7  be          
    JP  NZ,BITMAP3                      ;dae8  c2 f6 da    
    INC HL                              ;daeb  23          
    LD  A,(HL)                          ;daec  7e          ;yes, does name start with a '$'?
    SUB '$'                             ;daed  d6 24       
    JP  NZ,BITMAP3                      ;daef  c2 f6 da    
    DEC A                               ;daf2  3d          ;yes, set atatus to minus one.
    LD  (STATUS),A                      ;daf3  32 45 d7    
BITMAP3:LD  C,1                         ;daf6  0e 01       ;now set this file's space as used in bit map.
    CALL    SETFILE                     ;daf8  cd 6b da    
    CALL    CHKNMBR                     ;dafb  cd 8c d9    ;keep (SCRATCH1) in bounds.
    JP  BITMAP2                         ;dafe  c3 d2 da    
                  ;
                  ;   Set the status (STATUS) and return.
                  ;
STSTATUS: LD    A,(FNDSTAT)             ;db01  3a d4 e1    
    JP  SETSTAT                         ;db04  c3 01 d7    
                  ;
                  ;   Check extents in (A) and (C). Set the zero flag if they
                  ; are the same. The number of 16k chunks of disk space that
                  ; the directory extent covers is expressad is (EXTMASK+1).
                  ; No registers are modified.
                  ;
SAMEXT: PUSH    BC                      ;db07  c5          
    PUSH    AF                          ;db08  f5          
    LD  A,(EXTMASK)                     ;db09  3a c5 e1    ;get extent mask and use it to
    CPL                                 ;db0c  2f          ;to compare both extent numbers.
    LD  B,A                             ;db0d  47          ;save resulting mask here.
    LD  A,C                             ;db0e  79          ;mask first extent and save in (C).
    AND B                               ;db0f  a0          
    LD  C,A                             ;db10  4f          
    POP AF                              ;db11  f1          ;now mask second extent and compare
    AND B                               ;db12  a0          ;with the first one.
    SUB C                               ;db13  91          
    AND 1FH                             ;db14  e6 1f       ;(* only check buts 0-4 *)
    POP BC                              ;db16  c1          ;the zero flag is set if they are the same.
    RET                                 ;db17  c9          ;restore (BC) and return.
                  ;
                  ;   Search for the first occurence of a file name. On entry,
                  ; register (C) should contain the number of bytes of the fcb
                  ; that must match.
                  ;
FINDFST:LD  A,0FFH                      ;db18  3e ff       
    LD  (FNDSTAT),A                     ;db1a  32 d4 e1    
    LD  HL,COUNTER                      ;db1d  21 d8 e1    ;save character count.
    LD  (HL),C                          ;db20  71          
    LD  HL,(PARAMS)                     ;db21  2a 43 d7    ;get filename to match.
    LD  (SAVEFCB),HL                    ;db24  22 d9 e1    ;and save.
    CALL    STFILPOS                    ;db27  cd fe d9    ;clear initial file position (set to 0ffffh).
    CALL    HOMEDRV                     ;db2a  cd a1 d7    ;home the drive.
                  ;
                  ;   Entry to locate the next occurence of a filename within the
                  ; directory. The disk is not expected to have been changed. If
                  ; it was, then it will be write protected.
                  ;
FINDNXT:LD  C,0                         ;db2d  0e 00       ;write protect the disk if changed.
    CALL    NXENTRY                     ;db2f  cd 05 da    ;get next filename entry in directory.
    CALL    CKFILPOS                    ;db32  cd f5 d9    ;is file position = 0ffffh?
    JP  Z,FNDNXT6                       ;db35  ca 94 db    ;yes, exit now then.
    LD  HL,(SAVEFCB)                    ;db38  2a d9 e1    ;set (DE) pointing to filename to match.
    EX  DE,HL                           ;db3b  eb          
    LD  A,(DE)                          ;db3c  1a          
    CP  0E5H                            ;db3d  fe e5       ;empty directory entry?
    JP  Z,FNDNXT1                       ;db3f  ca 4a db    ;(* are we trying to reserect erased entries? *)
    PUSH    DE                          ;db42  d5          
    CALL    MOREFLS                     ;db43  cd 7f d9    ;more files in directory?
    POP DE                              ;db46  d1          
    JP  NC,FNDNXT6                      ;db47  d2 94 db    ;no more. Exit now.
FNDNXT1:CALL    FCB2HL                  ;db4a  cd 5e d9    ;get address of this fcb in directory.
    LD  A,(COUNTER)                     ;db4d  3a d8 e1    ;get number of bytes (characters) to check.
    LD  C,A                             ;db50  4f          
    LD  B,0                             ;db51  06 00       ;initialize byte position counter.
FNDNXT2:LD  A,C                         ;db53  79          ;are we done with the compare?
    OR  A                               ;db54  b7          
    JP  Z,FNDNXT5                       ;db55  ca 83 db    
    LD  A,(DE)                          ;db58  1a          ;no, check next byte.
    CP  '?'                             ;db59  fe 3f       ;don't care about this character?
    JP  Z,FNDNXT4                       ;db5b  ca 7c db    
    LD  A,B                             ;db5e  78          ;get bytes position in fcb.
    CP  13                              ;db5f  fe 0d       ;don't care about the thirteenth byte either.
    JP  Z,FNDNXT4                       ;db61  ca 7c db    
    CP  12                              ;db64  fe 0c       ;extent byte?
    LD  A,(DE)                          ;db66  1a          
    JP  Z,FNDNXT3                       ;db67  ca 73 db    
    SUB (HL)                            ;db6a  96          ;otherwise compare characters.
    AND 7FH                             ;db6b  e6 7f       
    JP  NZ,FINDNXT                      ;db6d  c2 2d db    ;not the same, check next entry.
    JP  FNDNXT4                         ;db70  c3 7c db    ;so far so good, keep checking.
FNDNXT3:PUSH    BC                      ;db73  c5          ;check the extent byte here.
    LD  C,(HL)                          ;db74  4e          
    CALL    SAMEXT                      ;db75  cd 07 db    
    POP BC                              ;db78  c1          
    JP  NZ,FINDNXT                      ;db79  c2 2d db    ;not the same, look some more.
                  ;
                  ;   So far the names compare. Bump pointers to the next byte
                  ; and continue until all (C) characters have been checked.
                  ;
FNDNXT4:INC DE                          ;db7c  13          ;bump pointers.
    INC HL                              ;db7d  23          
    INC B                               ;db7e  04          
    DEC C                               ;db7f  0d          ;adjust character counter.
    JP  FNDNXT2                         ;db80  c3 53 db    
FNDNXT5:LD  A,(FILEPOS)                 ;db83  3a ea e1    ;return the position of this entry.
    AND 03H                             ;db86  e6 03       
    LD  (STATUS),A                      ;db88  32 45 d7    
    LD  HL,FNDSTAT                      ;db8b  21 d4 e1    
    LD  A,(HL)                          ;db8e  7e          
    RLA                                 ;db8f  17          
    RET NC                              ;db90  d0          
    XOR A                               ;db91  af          
    LD  (HL),A                          ;db92  77          
    RET                                 ;db93  c9          
                  ;
                  ;   Filename was not found. Set appropriate status.
                  ;
FNDNXT6:CALL    STFILPOS                ;db94  cd fe d9    ;set (FILEPOS) to 0ffffh.
    LD  A,0FFH                          ;db97  3e ff       ;say not located.
    JP  SETSTAT                         ;db99  c3 01 d7    
                  ;
                  ;   Erase files from the directory. Only the first byte of the
                  ; fcb will be affected. It is set to (E5).
                  ;
ERAFILE:CALL    CHKWPRT                 ;db9c  cd 54 d9    ;is disk write protected?
    LD  C,12                            ;db9f  0e 0c       ;only compare file names.
    CALL    FINDFST                     ;dba1  cd 18 db    ;get first file name.
ERAFIL1:CALL    CKFILPOS                ;dba4  cd f5 d9    ;any found?
    RET Z                               ;dba7  c8          ;nope, we must be done.
    CALL    CHKROFL                     ;dba8  cd 44 d9    ;is file read only?
    CALL    FCB2HL                      ;dbab  cd 5e d9    ;nope, get address of fcb and
    LD  (HL),0E5H                       ;dbae  36 e5       ;set first byte to 'empty'.
    LD  C,0                             ;dbb0  0e 00       ;clear the space from the bit map.
    CALL    SETFILE                     ;dbb2  cd 6b da    
    CALL    DIRWRITE                    ;dbb5  cd c6 d9    ;now write the directory sector back out.
    CALL    FINDNXT                     ;dbb8  cd 2d db    ;find the next file name.
    JP  ERAFIL1                         ;dbbb  c3 a4 db    ;and repeat process.
                  ;
                  ;   Look through the space allocation map (bit map) for the
                  ; next available block. Start searching at block number (BC-1).
                  ; The search procedure is to look for an empty block that is
                  ; before the starting block. If not empty, look at a later
                  ; block number. In this way, we return the closest empty block
                  ; on either side of the 'target' block number. This will speed
                  ; access on random devices. For serial devices, this should be
                  ; changed to look in the forward direction first and then start
                  ; at the front and search some more.
                  ;
                  ;   On return, (DE)= block number that is empty and (HL) =0
                  ; if no empry block was found.
                  ;
FNDSPACE: LD    D,B                     ;dbbe  50          ;set (DE) as the block that is checked.
    LD  E,C                             ;dbbf  59          
                  ;
                  ;   Look before target block. Registers (BC) are used as the lower
                  ; pointer and (DE) as the upper pointer.
                  ;
FNDSPA1:LD  A,C                         ;dbc0  79          ;is block 0 specified?
    OR  B                               ;dbc1  b0          
    JP  Z,FNDSPA2                       ;dbc2  ca d1 db    
    DEC BC                              ;dbc5  0b          ;nope, check previous block.
    PUSH    DE                          ;dbc6  d5          
    PUSH    BC                          ;dbc7  c5          
    CALL    CKBITMAP                    ;dbc8  cd 35 da    
    RRA                                 ;dbcb  1f          ;is this block empty?
    JP  NC,FNDSPA3                      ;dbcc  d2 ec db    ;yes. use this.
                  ;
                  ;   Note that the above logic gets the first block that it finds
                  ; that is empty. Thus a file could be written 'backward' making
                  ; it very slow to access. This could be changed to look for the
                  ; first empty block and then continue until the start of this
                  ; empty space is located and then used that starting block.
                  ; This should help speed up access to some files especially on
                  ; a well used disk with lots of fairly small 'holes'.
                  ;
    POP BC                              ;dbcf  c1          ;nope, check some more.
    POP DE                              ;dbd0  d1          
                  ;
                  ;   Now look after target block.
                  ;
FNDSPA2:LD  HL,(DSKSIZE)                ;dbd1  2a c6 e1    ;is block (DE) within disk limits?
    LD  A,E                             ;dbd4  7b          
    SUB L                               ;dbd5  95          
    LD  A,D                             ;dbd6  7a          
    SBC A,H                             ;dbd7  9c          
    JP  NC,FNDSPA4                      ;dbd8  d2 f4 db    
    INC DE                              ;dbdb  13          ;yes, move on to next one.
    PUSH    BC                          ;dbdc  c5          
    PUSH    DE                          ;dbdd  d5          
    LD  B,D                             ;dbde  42          
    LD  C,E                             ;dbdf  4b          
    CALL    CKBITMAP                    ;dbe0  cd 35 da    ;check it.
    RRA                                 ;dbe3  1f          ;empty?
    JP  NC,FNDSPA3                      ;dbe4  d2 ec db    
    POP DE                              ;dbe7  d1          ;nope, continue searching.
    POP BC                              ;dbe8  c1          
    JP  FNDSPA1                         ;dbe9  c3 c0 db    
                  ;
                  ;   Empty block found. Set it as used and return with (HL)
                  ; pointing to it (true?).
                  ;
FNDSPA3:RLA                             ;dbec  17          ;reset byte.
    INC A                               ;dbed  3c          ;and set bit 0.
    CALL    STBMAP1                     ;dbee  cd 64 da    ;update bit map.
    POP HL                              ;dbf1  e1          ;set return registers.
    POP DE                              ;dbf2  d1          
    RET                                 ;dbf3  c9          
                  ;
                  ;   Free block was not found. If (BC) is not zero, then we have
                  ; not checked all of the disk space.
                  ;
FNDSPA4:LD  A,C                         ;dbf4  79          
    OR  B                               ;dbf5  b0          
    JP  NZ,FNDSPA1                      ;dbf6  c2 c0 db    
    LD  HL,0                            ;dbf9  21 00 00    ;set 'not found' status.
    RET                                 ;dbfc  c9          
                  ;
                  ;   Move a complete fcb entry into the directory and write it.
                  ;
FCBSET: LD  C,0                         ;dbfd  0e 00       
    LD  E,32                            ;dbff  1e 20       ;length of each entry.
                  ;
                  ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
                  ; fcb in directory starting at relative byte (C). This updated
                  ; directory buffer is then written to the disk.
                  ;
UPDATE: PUSH    DE                      ;dc01  d5          
    LD  B,0                             ;dc02  06 00       ;set (BC) to relative byte position.
    LD  HL,(PARAMS)                     ;dc04  2a 43 d7    ;get address of fcb.
    ADD HL,BC                           ;dc07  09          ;compute starting byte.
    EX  DE,HL                           ;dc08  eb          
    CALL    FCB2HL                      ;dc09  cd 5e d9    ;get address of fcb to update in directory.
    POP BC                              ;dc0c  c1          ;set (C) to number of bytes to change.
    CALL    DE2HL                       ;dc0d  cd 4f d7    
UPDATE1:CALL    TRKSEC                  ;dc10  cd c3 d7    ;determine the track and sector affected.
    JP  DIRWRITE                        ;dc13  c3 c6 d9    ;then write this sector out.
                  ;
                  ;   Routine to change the name of all files on the disk with a
                  ; specified name. The fcb contains the current name as the
                  ; first 12 characters and the new name 16 bytes into the fcb.
                  ;
CHGNAMES: CALL  CHKWPRT                 ;dc16  cd 54 d9    ;check for a write protected disk.
    LD  C,12                            ;dc19  0e 0c       ;match first 12 bytes of fcb only.
    CALL    FINDFST                     ;dc1b  cd 18 db    ;get first name.
    LD  HL,(PARAMS)                     ;dc1e  2a 43 d7    ;get address of fcb.
    LD  A,(HL)                          ;dc21  7e          ;get user number.
    LD  DE,16                           ;dc22  11 10 00    ;move over to desired name.
    ADD HL,DE                           ;dc25  19          
    LD  (HL),A                          ;dc26  77          ;keep same user number.
CHGNAM1:CALL    CKFILPOS                ;dc27  cd f5 d9    ;any matching file found?
    RET Z                               ;dc2a  c8          ;no, we must be done.
    CALL    CHKROFL                     ;dc2b  cd 44 d9    ;check for read only file.
    LD  C,16                            ;dc2e  0e 10       ;start 16 bytes into fcb.
    LD  E,12                            ;dc30  1e 0c       ;and update the first 12 bytes of directory.
    CALL    UPDATE                      ;dc32  cd 01 dc    
    CALL    FINDNXT                     ;dc35  cd 2d db    ;get te next file name.
    JP  CHGNAM1                         ;dc38  c3 27 dc    ;and continue.
                  ;
                  ;   Update a files attributes. The procedure is to search for
                  ; every file with the same name as shown in fcb (ignoring bit 7)
                  ; and then to update it (which includes bit 7). No other changes
                  ; are made.
                  ;
SAVEATTR: LD    C,12                    ;dc3b  0e 0c       ;match first 12 bytes.
    CALL    FINDFST                     ;dc3d  cd 18 db    ;look for first filename.
SAVATR1:CALL    CKFILPOS                ;dc40  cd f5 d9    ;was one found?
    RET Z                               ;dc43  c8          ;nope, we must be done.
    LD  C,0                             ;dc44  0e 00       ;yes, update the first 12 bytes now.
    LD  E,12                            ;dc46  1e 0c       
    CALL    UPDATE                      ;dc48  cd 01 dc    ;update filename and write directory.
    CALL    FINDNXT                     ;dc4b  cd 2d db    ;and get the next file.
    JP  SAVATR1                         ;dc4e  c3 40 dc    ;then continue until done.
                  ;
                  ;  Open a file (name specified in fcb).
                  ;
OPENIT: LD  C,15                        ;dc51  0e 0f       ;compare the first 15 bytes.
    CALL    FINDFST                     ;dc53  cd 18 db    ;get the first one in directory.
    CALL    CKFILPOS                    ;dc56  cd f5 d9    ;any at all?
    RET Z                               ;dc59  c8          
OPENIT1:CALL    SETEXT                  ;dc5a  cd a6 d8    ;point to extent byte within users fcb.
    LD  A,(HL)                          ;dc5d  7e          ;and get it.
    PUSH    AF                          ;dc5e  f5          ;save it and address.
    PUSH    HL                          ;dc5f  e5          
    CALL    FCB2HL                      ;dc60  cd 5e d9    ;point to fcb in directory.
    EX  DE,HL                           ;dc63  eb          
    LD  HL,(PARAMS)                     ;dc64  2a 43 d7    ;this is the users copy.
    LD  C,32                            ;dc67  0e 20       ;move it into users space.
    PUSH    DE                          ;dc69  d5          
    CALL    DE2HL                       ;dc6a  cd 4f d7    
    CALL    SETS2B7                     ;dc6d  cd 78 d9    ;set bit 7 in 's2' byte (unmodified).
    POP DE                              ;dc70  d1          ;now get the extent byte from this fcb.
    LD  HL,12                           ;dc71  21 0c 00    
    ADD HL,DE                           ;dc74  19          
    LD  C,(HL)                          ;dc75  4e          ;into (C).
    LD  HL,15                           ;dc76  21 0f 00    ;now get the record count byte into (B).
    ADD HL,DE                           ;dc79  19          
    LD  B,(HL)                          ;dc7a  46          
    POP HL                              ;dc7b  e1          ;keep the same extent as the user had originally.
    POP AF                              ;dc7c  f1          
    LD  (HL),A                          ;dc7d  77          
    LD  A,C                             ;dc7e  79          ;is it the same as in the directory fcb?
    CP  (HL)                            ;dc7f  be          
    LD  A,B                             ;dc80  78          ;if yes, then use the same record count.
    JP  Z,OPENIT2                       ;dc81  ca 8b dc    
    LD  A,0                             ;dc84  3e 00       ;if the user specified an extent greater than
    JP  C,OPENIT2                       ;dc86  da 8b dc    ;the one in the directory, then set record count to 0.
    LD  A,128                           ;dc89  3e 80       ;otherwise set to maximum.
OPENIT2:LD  HL,(PARAMS)                 ;dc8b  2a 43 d7    ;set record count in users fcb to (A).
    LD  DE,15                           ;dc8e  11 0f 00    
    ADD HL,DE                           ;dc91  19          ;compute relative position.
    LD  (HL),A                          ;dc92  77          ;and set the record count.
    RET                                 ;dc93  c9          
                  ;
                  ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
                  ; point to a zero value (16 bit).
                  ;   Return with zero flag set it (DE) was moved. Registers (DE)
                  ; and (HL) are not changed. However (A) is.
                  ;
MOVEWORD: LD    A,(HL)                  ;dc94  7e          ;check for a zero word.
    INC HL                              ;dc95  23          
    OR  (HL)                            ;dc96  b6          ;both bytes zero?
    DEC HL                              ;dc97  2b          
    RET NZ                              ;dc98  c0          ;nope, just return.
    LD  A,(DE)                          ;dc99  1a          ;yes, move two bytes from (DE) into
    LD  (HL),A                          ;dc9a  77          ;this zero space.
    INC DE                              ;dc9b  13          
    INC HL                              ;dc9c  23          
    LD  A,(DE)                          ;dc9d  1a          
    LD  (HL),A                          ;dc9e  77          
    DEC DE                              ;dc9f  1b          ;don't disturb these registers.
    DEC HL                              ;dca0  2b          
    RET                                 ;dca1  c9          
                  ;
                  ;   Get here to close a file specified by (fcb).
                  ;
CLOSEIT:XOR A                           ;dca2  af          ;clear status and file position bytes.
    LD  (STATUS),A                      ;dca3  32 45 d7    
    LD  (FILEPOS),A                     ;dca6  32 ea e1    
    LD  (FILEPOS+1),A                   ;dca9  32 eb e1    
    CALL    GETWPRT                     ;dcac  cd 1e d9    ;get write protect bit for this drive.
    RET NZ                              ;dcaf  c0          ;just return if it is set.
    CALL    GETS2                       ;dcb0  cd 69 d9    ;else get the 's2' byte.
    AND 80H                             ;dcb3  e6 80       ;and look at bit 7 (file unmodified?).
    RET NZ                              ;dcb5  c0          ;just return if set.
    LD  C,15                            ;dcb6  0e 0f       ;else look up this file in directory.
    CALL    FINDFST                     ;dcb8  cd 18 db    
    CALL    CKFILPOS                    ;dcbb  cd f5 d9    ;was it found?
    RET Z                               ;dcbe  c8          ;just return if not.
    LD  BC,16                           ;dcbf  01 10 00    ;set (HL) pointing to records used section.
    CALL    FCB2HL                      ;dcc2  cd 5e d9    
    ADD HL,BC                           ;dcc5  09          
    EX  DE,HL                           ;dcc6  eb          
    LD  HL,(PARAMS)                     ;dcc7  2a 43 d7    ;do the same for users specified fcb.
    ADD HL,BC                           ;dcca  09          
    LD  C,16                            ;dccb  0e 10       ;this many bytes are present in this extent.
CLOSEIT1: LD    A,(BIGDISK)             ;dccd  3a dd e1    ;8 or 16 bit record numbers?
    OR  A                               ;dcd0  b7          
    JP  Z,CLOSEIT4                      ;dcd1  ca e8 dc    
    LD  A,(HL)                          ;dcd4  7e          ;just 8 bit. Get one from users fcb.
    OR  A                               ;dcd5  b7          
    LD  A,(DE)                          ;dcd6  1a          ;now get one from directory fcb.
    JP  NZ,CLOSEIT2                     ;dcd7  c2 db dc    
    LD  (HL),A                          ;dcda  77          ;users byte was zero. Update from directory.
CLOSEIT2: OR    A                       ;dcdb  b7          
    JP  NZ,CLOSEIT3                     ;dcdc  c2 e1 dc    
    LD  A,(HL)                          ;dcdf  7e          ;directories byte was zero, update from users fcb.
    LD  (DE),A                          ;dce0  12          
CLOSEIT3: CP    (HL)                    ;dce1  be          ;if neither one of these bytes were zero,
    JP  NZ,CLOSEIT7                     ;dce2  c2 1f dd    ;then close error if they are not the same.
    JP  CLOSEIT5                        ;dce5  c3 fd dc    ;ok so far, get to next byte in fcbs.
CLOSEIT4: CALL  MOVEWORD                ;dce8  cd 94 dc    ;update users fcb if it is zero.
    EX  DE,HL                           ;dceb  eb          
    CALL    MOVEWORD                    ;dcec  cd 94 dc    ;update directories fcb if it is zero.
    EX  DE,HL                           ;dcef  eb          
    LD  A,(DE)                          ;dcf0  1a          ;if these two values are no different,
    CP  (HL)                            ;dcf1  be          ;then a close error occured.
    JP  NZ,CLOSEIT7                     ;dcf2  c2 1f dd    
    INC DE                              ;dcf5  13          ;check second byte.
    INC HL                              ;dcf6  23          
    LD  A,(DE)                          ;dcf7  1a          
    CP  (HL)                            ;dcf8  be          
    JP  NZ,CLOSEIT7                     ;dcf9  c2 1f dd    
    DEC C                               ;dcfc  0d          ;remember 16 bit values.
CLOSEIT5: INC   DE                      ;dcfd  13          ;bump to next item in table.
    INC HL                              ;dcfe  23          
    DEC C                               ;dcff  0d          ;there are 16 entries only.
    JP  NZ,CLOSEIT1                     ;dd00  c2 cd dc    ;continue if more to do.
    LD  BC,0FFECH                       ;dd03  01 ec ff    ;backup 20 places (extent byte).
    ADD HL,BC                           ;dd06  09          
    EX  DE,HL                           ;dd07  eb          
    ADD HL,BC                           ;dd08  09          
    LD  A,(DE)                          ;dd09  1a          
    CP  (HL)                            ;dd0a  be          ;directory's extent already greater than the
    JP  C,CLOSEIT6                      ;dd0b  da 17 dd    ;users extent?
    LD  (HL),A                          ;dd0e  77          ;no, update directory extent.
    LD  BC,3                            ;dd0f  01 03 00    ;and update the record count byte in
    ADD HL,BC                           ;dd12  09          ;directories fcb.
    EX  DE,HL                           ;dd13  eb          
    ADD HL,BC                           ;dd14  09          
    LD  A,(HL)                          ;dd15  7e          ;get from user.
    LD  (DE),A                          ;dd16  12          ;and put in directory.
CLOSEIT6: LD    A,0FFH                  ;dd17  3e ff       ;set 'was open and is now closed' byte.
    LD  (CLOSEFLG),A                    ;dd19  32 d2 e1    
    JP  UPDATE1                         ;dd1c  c3 10 dc    ;update the directory now.
CLOSEIT7: LD    HL,STATUS               ;dd1f  21 45 d7    ;set return status and then return.
    DEC (HL)                            ;dd22  35          
    RET                                 ;dd23  c9          
                  ;
                  ;   Routine to get the next empty space in the directory. It
                  ; will then be cleared for use.
                  ;
GETEMPTY: CALL  CHKWPRT                 ;dd24  cd 54 d9    ;make sure disk is not write protected.
    LD  HL,(PARAMS)                     ;dd27  2a 43 d7    ;save current parameters (fcb).
    PUSH    HL                          ;dd2a  e5          
    LD  HL,EMPTYFCB                     ;dd2b  21 ac e1    ;use special one for empty space.
    LD  (PARAMS),HL                     ;dd2e  22 43 d7    
    LD  C,1                             ;dd31  0e 01       ;search for first empty spot in directory.
    CALL    FINDFST                     ;dd33  cd 18 db    ;(* only check first byte *)
    CALL    CKFILPOS                    ;dd36  cd f5 d9    ;none?
    POP HL                              ;dd39  e1          
    LD  (PARAMS),HL                     ;dd3a  22 43 d7    ;restore original fcb address.
    RET Z                               ;dd3d  c8          ;return if no more space.
    EX  DE,HL                           ;dd3e  eb          
    LD  HL,15                           ;dd3f  21 0f 00    ;point to number of records for this file.
    ADD HL,DE                           ;dd42  19          
    LD  C,17                            ;dd43  0e 11       ;and clear all of this space.
    XOR A                               ;dd45  af          
GETMT1: LD  (HL),A                      ;dd46  77          
    INC HL                              ;dd47  23          
    DEC C                               ;dd48  0d          
    JP  NZ,GETMT1                       ;dd49  c2 46 dd    
    LD  HL,13                           ;dd4c  21 0d 00    ;clear the 's1' byte also.
    ADD HL,DE                           ;dd4f  19          
    LD  (HL),A                          ;dd50  77          
    CALL    CHKNMBR                     ;dd51  cd 8c d9    ;keep (SCRATCH1) within bounds.
    CALL    FCBSET                      ;dd54  cd fd db    ;write out this fcb entry to directory.
    JP  SETS2B7                         ;dd57  c3 78 d9    ;set 's2' byte bit 7 (unmodified at present).
                  ;
                  ;   Routine to close the current extent and open the next one
                  ; for reading.
                  ;
GETNEXT:XOR A                           ;dd5a  af          
    LD  (CLOSEFLG),A                    ;dd5b  32 d2 e1    ;clear close flag.
    CALL    CLOSEIT                     ;dd5e  cd a2 dc    ;close this extent.
    CALL    CKFILPOS                    ;dd61  cd f5 d9    
    RET Z                               ;dd64  c8          ;not there???
    LD  HL,(PARAMS)                     ;dd65  2a 43 d7    ;get extent byte.
    LD  BC,12                           ;dd68  01 0c 00    
    ADD HL,BC                           ;dd6b  09          
    LD  A,(HL)                          ;dd6c  7e          ;and increment it.
    INC A                               ;dd6d  3c          
    AND 1FH                             ;dd6e  e6 1f       ;keep within range 0-31.
    LD  (HL),A                          ;dd70  77          
    JP  Z,GTNEXT1                       ;dd71  ca 83 dd    ;overflow?
    LD  B,A                             ;dd74  47          ;mask extent byte.
    LD  A,(EXTMASK)                     ;dd75  3a c5 e1    
    AND B                               ;dd78  a0          
    LD  HL,CLOSEFLG                     ;dd79  21 d2 e1    ;check close flag (0ffh is ok).
    AND (HL)                            ;dd7c  a6          
    JP  Z,GTNEXT2                       ;dd7d  ca 8e dd    ;if zero, we must read in next extent.
    JP  GTNEXT3                         ;dd80  c3 ac dd    ;else, it is already in memory.
GTNEXT1:LD  BC,2                        ;dd83  01 02 00    ;Point to the 's2' byte.
    ADD HL,BC                           ;dd86  09          
    INC (HL)                            ;dd87  34          ;and bump it.
    LD  A,(HL)                          ;dd88  7e          ;too many extents?
    AND 0FH                             ;dd89  e6 0f       
    JP  Z,GTNEXT5                       ;dd8b  ca b6 dd    ;yes, set error code.
                  ;
                  ;   Get here to open the next extent.
                  ;
GTNEXT2:LD  C,15                        ;dd8e  0e 0f       ;set to check first 15 bytes of fcb.
    CALL    FINDFST                     ;dd90  cd 18 db    ;find the first one.
    CALL    CKFILPOS                    ;dd93  cd f5 d9    ;none available?
    JP  NZ,GTNEXT3                      ;dd96  c2 ac dd    
    LD  A,(RDWRTFLG)                    ;dd99  3a d3 e1    ;no extent present. Can we open an empty one?
    INC A                               ;dd9c  3c          ;0ffh means reading (so not possible).
    JP  Z,GTNEXT5                       ;dd9d  ca b6 dd    ;or an error.
    CALL    GETEMPTY                    ;dda0  cd 24 dd    ;we are writing, get an empty entry.
    CALL    CKFILPOS                    ;dda3  cd f5 d9    ;none?
    JP  Z,GTNEXT5                       ;dda6  ca b6 dd    ;error if true.
    JP  GTNEXT4                         ;dda9  c3 af dd    ;else we are almost done.
GTNEXT3:CALL    OPENIT1                 ;ddac  cd 5a dc    ;open this extent.
GTNEXT4:CALL    STRDATA                 ;ddaf  cd bb d8    ;move in updated data (rec #, extent #, etc.)
    XOR A                               ;ddb2  af          ;clear status and return.
    JP  SETSTAT                         ;ddb3  c3 01 d7    
                  ;
                  ;   Error in extending the file. Too many extents were needed
                  ; or not enough space on the disk.
                  ;
GTNEXT5:CALL    IOERR1                  ;ddb6  cd 05 d7    ;set error code, clear bit 7 of 's2'
    JP  SETS2B7                         ;ddb9  c3 78 d9    ;so this is not written on a close.
                  ;
                  ;   Read a sequential file.
                  ;
RDSEQ:  LD  A,1                         ;ddbc  3e 01       ;set sequential access mode.
    LD  (MODE),A                        ;ddbe  32 d5 e1    
RDSEQ1: LD  A,0FFH                      ;ddc1  3e ff       ;don't allow reading unwritten space.
    LD  (RDWRTFLG),A                    ;ddc3  32 d3 e1    
    CALL    STRDATA                     ;ddc6  cd bb d8    ;put rec# and ext# into fcb.
    LD  A,(SAVNREC)                     ;ddc9  3a e3 e1    ;get next record to read.
    LD  HL,SAVNXT                       ;ddcc  21 e1 e1    ;get number of records in extent.
    CP  (HL)                            ;ddcf  be          ;within this extent?
    JP  C,RDSEQ2                        ;ddd0  da e6 dd    
    CP  128                             ;ddd3  fe 80       ;no. Is this extent fully used?
    JP  NZ,RDSEQ3                       ;ddd5  c2 fb dd    ;no. End-of-file.
    CALL    GETNEXT                     ;ddd8  cd 5a dd    ;yes, open the next one.
    XOR A                               ;dddb  af          ;reset next record to read.
    LD  (SAVNREC),A                     ;dddc  32 e3 e1    
    LD  A,(STATUS)                      ;dddf  3a 45 d7    ;check on open, successful?
    OR  A                               ;dde2  b7          
    JP  NZ,RDSEQ3                       ;dde3  c2 fb dd    ;no, error.
RDSEQ2: CALL    COMBLK                  ;dde6  cd 77 d8    ;ok. compute block number to read.
    CALL    CHKBLK                      ;dde9  cd 84 d8    ;check it. Within bounds?
    JP  Z,RDSEQ3                        ;ddec  ca fb dd    ;no, error.
    CALL    LOGICAL                     ;ddef  cd 8a d8    ;convert (BLKNMBR) to logical sector (128 byte).
    CALL    TRKSEC1                     ;ddf2  cd d1 d7    ;set the track and sector for this block #.
    CALL    DOREAD                      ;ddf5  cd b2 d7    ;and read it.
    JP  SETNREC                         ;ddf8  c3 d2 d8    ;and set the next record to be accessed.
                  ;
                  ;   Read error occured. Set status and return.
                  ;
RDSEQ3: JP  IOERR1                      ;ddfb  c3 05 d7    
                  ;
                  ;   Write the next sequential record.
                  ;
WTSEQ:  LD  A,1                         ;ddfe  3e 01       ;set sequential access mode.
    LD  (MODE),A                        ;de00  32 d5 e1    
WTSEQ1: LD  A,0                         ;de03  3e 00       ;allow an addition empty extent to be opened.
    LD  (RDWRTFLG),A                    ;de05  32 d3 e1    
    CALL    CHKWPRT                     ;de08  cd 54 d9    ;check write protect status.
    LD  HL,(PARAMS)                     ;de0b  2a 43 d7    
    CALL    CKROF1                      ;de0e  cd 47 d9    ;check for read only file, (HL) already set to fcb.
    CALL    STRDATA                     ;de11  cd bb d8    ;put updated data into fcb.
    LD  A,(SAVNREC)                     ;de14  3a e3 e1    ;get record number to write.
    CP  128                             ;de17  fe 80       ;within range?
    JP  NC,IOERR1                       ;de19  d2 05 d7    ;no, error(?).
    CALL    COMBLK                      ;de1c  cd 77 d8    ;compute block number.
    CALL    CHKBLK                      ;de1f  cd 84 d8    ;check number.
    LD  C,0                             ;de22  0e 00       ;is there one to write to?
    JP  NZ,WTSEQ6                       ;de24  c2 6e de    ;yes, go do it.
    CALL    GETBLOCK                    ;de27  cd 3e d8    ;get next block number within fcb to use.
    LD  (RELBLOCK),A                    ;de2a  32 d7 e1    ;and save.
    LD  BC,0                            ;de2d  01 00 00    ;start looking for space from the start
    OR  A                               ;de30  b7          ;if none allocated as yet.
    JP  Z,WTSEQ2                        ;de31  ca 3b de    
    LD  C,A                             ;de34  4f          ;extract previous block number from fcb
    DEC BC                              ;de35  0b          ;so we can be closest to it.
    CALL    EXTBLK                      ;de36  cd 5e d8    
    LD  B,H                             ;de39  44          
    LD  C,L                             ;de3a  4d          
WTSEQ2: CALL    FNDSPACE                ;de3b  cd be db    ;find the next empty block nearest number (BC).
    LD  A,L                             ;de3e  7d          ;check for a zero number.
    OR  H                               ;de3f  b4          
    JP  NZ,WTSEQ3                       ;de40  c2 48 de    
    LD  A,2                             ;de43  3e 02       ;no more space?
    JP  SETSTAT                         ;de45  c3 01 d7    
WTSEQ3: LD  (BLKNMBR),HL                ;de48  22 e5 e1    ;save block number to access.
    EX  DE,HL                           ;de4b  eb          ;put block number into (DE).
    LD  HL,(PARAMS)                     ;de4c  2a 43 d7    ;now we must update the fcb for this
    LD  BC,16                           ;de4f  01 10 00    ;newly allocated block.
    ADD HL,BC                           ;de52  09          
    LD  A,(BIGDISK)                     ;de53  3a dd e1    ;8 or 16 bit block numbers?
    OR  A                               ;de56  b7          
    LD  A,(RELBLOCK)                    ;de57  3a d7 e1    ;(* update this entry *)
    JP  Z,WTSEQ4                        ;de5a  ca 64 de    ;zero means 16 bit ones.
    CALL    ADDA2HL                     ;de5d  cd 64 d9    ;(HL)=(HL)+(A)
    LD  (HL),E                          ;de60  73          ;store new block number.
    JP  WTSEQ5                          ;de61  c3 6c de    
WTSEQ4: LD  C,A                         ;de64  4f          ;compute spot in this 16 bit table.
    LD  B,0                             ;de65  06 00       
    ADD HL,BC                           ;de67  09          
    ADD HL,BC                           ;de68  09          
    LD  (HL),E                          ;de69  73          ;stuff block number (DE) there.
    INC HL                              ;de6a  23          
    LD  (HL),D                          ;de6b  72          
WTSEQ5: LD  C,2                         ;de6c  0e 02       ;set (C) to indicate writing to un-used disk space.
WTSEQ6: LD  A,(STATUS)                  ;de6e  3a 45 d7    ;are we ok so far?
    OR  A                               ;de71  b7          
    RET NZ                              ;de72  c0          
    PUSH    BC                          ;de73  c5          ;yes, save write flag for bios (register C).
    CALL    LOGICAL                     ;de74  cd 8a d8    ;convert (BLKNMBR) over to loical sectors.
    LD  A,(MODE)                        ;de77  3a d5 e1    ;get access mode flag (1=sequential,
    DEC A                               ;de7a  3d          ;0=random, 2=special?).
    DEC A                               ;de7b  3d          
    JP  NZ,WTSEQ9                       ;de7c  c2 bb de    
                  ;
                  ;   Special random i/o from function #40. Maybe for M/PM, but the
                  ; current block, if it has not been written to, will be zeroed
                  ; out and then written (reason?).
                  ;
    POP BC                              ;de7f  c1          
    PUSH    BC                          ;de80  c5          
    LD  A,C                             ;de81  79          ;get write status flag (2=writing unused space).
    DEC A                               ;de82  3d          
    DEC A                               ;de83  3d          
    JP  NZ,WTSEQ9                       ;de84  c2 bb de    
    PUSH    HL                          ;de87  e5          
    LD  HL,(DIRBUF)                     ;de88  2a b9 e1    ;zero out the directory buffer.
    LD  D,A                             ;de8b  57          ;note that (A) is zero here.
WTSEQ7: LD  (HL),A                      ;de8c  77          
    INC HL                              ;de8d  23          
    INC D                               ;de8e  14          ;do 128 bytes.
    JP  P,WTSEQ7                        ;de8f  f2 8c de    
    CALL    DIRDMA                      ;de92  cd e0 d9    ;tell the bios the dma address for directory access.
    LD  HL,(LOGSECT)                    ;de95  2a e7 e1    ;get sector that starts current block.
    LD  C,2                             ;de98  0e 02       ;set 'writing to unused space' flag.
WTSEQ8: LD  (BLKNMBR),HL                ;de9a  22 e5 e1    ;save sector to write.
    PUSH    BC                          ;de9d  c5          
    CALL    TRKSEC1                     ;de9e  cd d1 d7    ;determine its track and sector numbers.
    POP BC                              ;dea1  c1          
    CALL    DOWRITE                     ;dea2  cd b8 d7    ;now write out 128 bytes of zeros.
    LD  HL,(BLKNMBR)                    ;dea5  2a e5 e1    ;get sector number.
    LD  C,0                             ;dea8  0e 00       ;set normal write flag.
    LD  A,(BLKMASK)                     ;deaa  3a c4 e1    ;determine if we have written the entire
    LD  B,A                             ;dead  47          ;physical block.
    AND L                               ;deae  a5          
    CP  B                               ;deaf  b8          
    INC HL                              ;deb0  23          ;prepare for the next one.
    JP  NZ,WTSEQ8                       ;deb1  c2 9a de    ;continue until (BLKMASK+1) sectors written.
    POP HL                              ;deb4  e1          ;reset next sector number.
    LD  (BLKNMBR),HL                    ;deb5  22 e5 e1    
    CALL    DEFDMA                      ;deb8  cd da d9    ;and reset dma address.
                  ;
                  ;   Normal disk write. Set the desired track and sector then
                  ; do the actual write.
                  ;
WTSEQ9: CALL    TRKSEC1                 ;debb  cd d1 d7    ;determine track and sector for this write.
    POP BC                              ;debe  c1          ;get write status flag.
    PUSH    BC                          ;debf  c5          
    CALL    DOWRITE                     ;dec0  cd b8 d7    ;and write this out.
    POP BC                              ;dec3  c1          
    LD  A,(SAVNREC)                     ;dec4  3a e3 e1    ;get number of records in file.
    LD  HL,SAVNXT                       ;dec7  21 e1 e1    ;get last record written.
    CP  (HL)                            ;deca  be          
    JP  C,WTSEQ10                       ;decb  da d2 de    
    LD  (HL),A                          ;dece  77          ;we have to update record count.
    INC (HL)                            ;decf  34          
    LD  C,2                             ;ded0  0e 02       
                  ;
                  ;*   This area has been patched to correct disk update problem
                  ;* when using blocking and de-blocking in the BIOS.
                  ;
WTSEQ10:NOP                             ;ded2  00          ;was 'dcr c'
    NOP                                 ;ded3  00          ;was 'dcr c'
    LD  HL,0                            ;ded4  21 00 00    ;was 'jnz wtseq99'
                  ;
                  ; *   End of patch.
                  ;
    PUSH    AF                          ;ded7  f5          
    CALL    GETS2                       ;ded8  cd 69 d9    ;set 'extent written to' flag.
    AND 7FH                             ;dedb  e6 7f       ;(* clear bit 7 *)
    LD  (HL),A                          ;dedd  77          
    POP AF                              ;dede  f1          ;get record count for this extent.
WTSEQ99:CP  127                         ;dedf  fe 7f       ;is it full?
    JP  NZ,WTSEQ12                      ;dee1  c2 00 df    
    LD  A,(MODE)                        ;dee4  3a d5 e1    ;yes, are we in sequential mode?
    CP  1                               ;dee7  fe 01       
    JP  NZ,WTSEQ12                      ;dee9  c2 00 df    
    CALL    SETNREC                     ;deec  cd d2 d8    ;yes, set next record number.
    CALL    GETNEXT                     ;deef  cd 5a dd    ;and get next empty space in directory.
    LD  HL,STATUS                       ;def2  21 45 d7    ;ok?
    LD  A,(HL)                          ;def5  7e          
    OR  A                               ;def6  b7          
    JP  NZ,WTSEQ11                      ;def7  c2 fe de    
    DEC A                               ;defa  3d          ;yes, set record count to -1.
    LD  (SAVNREC),A                     ;defb  32 e3 e1    
WTSEQ11:LD  (HL),0                      ;defe  36 00       ;clear status.
WTSEQ12:JP  SETNREC                     ;df00  c3 d2 d8    ;set next record to access.
                  ;
                  ;   For random i/o, set the fcb for the desired record number
                  ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
                  ; used as follows:
                  ;
                  ;       fcb+35            fcb+34            fcb+33
                  ;  |     'r-2'      |      'r-1'      |      'r-0'     |
                  ;  |7             0 | 7             0 | 7             0|
                  ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
                  ;  |    overflow   | | extra |  extent   |   record #  |
                  ;  | ______________| |_extent|__number___|_____________|
                  ;                     also 's2'
                  ;
                  ;   On entry, register (C) contains 0ffh if this is a read
                  ; and thus we can not access unwritten disk space. Otherwise,
                  ; another extent will be opened (for writing) if required.
                  ;
POSITION: XOR   A                       ;df03  af          ;set random i/o flag.
    LD  (MODE),A                        ;df04  32 d5 e1    
                  ;
                  ;   Special entry (function #40). M/PM ?
                  ;
POSITN1:PUSH    BC                      ;df07  c5          ;save read/write flag.
    LD  HL,(PARAMS)                     ;df08  2a 43 d7    ;get address of fcb.
    EX  DE,HL                           ;df0b  eb          
    LD  HL,33                           ;df0c  21 21 00    ;now get byte 'r0'.
    ADD HL,DE                           ;df0f  19          
    LD  A,(HL)                          ;df10  7e          
    AND 7FH                             ;df11  e6 7f       ;keep bits 0-6 for the record number to access.
    PUSH    AF                          ;df13  f5          
    LD  A,(HL)                          ;df14  7e          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
    RLA                                 ;df15  17          
    INC HL                              ;df16  23          
    LD  A,(HL)                          ;df17  7e          
    RLA                                 ;df18  17          
    AND 1FH                             ;df19  e6 1f       ;and save this in bits 0-4 of (C).
    LD  C,A                             ;df1b  4f          ;this is the extent byte.
    LD  A,(HL)                          ;df1c  7e          ;now get the extra extent byte.
    RRA                                 ;df1d  1f          
    RRA                                 ;df1e  1f          
    RRA                                 ;df1f  1f          
    RRA                                 ;df20  1f          
    AND 0FH                             ;df21  e6 0f       
    LD  B,A                             ;df23  47          ;and save it in (B).
    POP AF                              ;df24  f1          ;get record number back to (A).
    INC HL                              ;df25  23          ;check overflow byte 'r2'.
    LD  L,(HL)                          ;df26  6e          
    INC L                               ;df27  2c          
    DEC L                               ;df28  2d          
    LD  L,6                             ;df29  2e 06       ;prepare for error.
    JP  NZ,POSITN5                      ;df2b  c2 8b df    ;out of disk space error.
    LD  HL,32                           ;df2e  21 20 00    ;store record number into fcb.
    ADD HL,DE                           ;df31  19          
    LD  (HL),A                          ;df32  77          
    LD  HL,12                           ;df33  21 0c 00    ;and now check the extent byte.
    ADD HL,DE                           ;df36  19          
    LD  A,C                             ;df37  79          
    SUB (HL)                            ;df38  96          ;same extent as before?
    JP  NZ,POSITN2                      ;df39  c2 47 df    
    LD  HL,14                           ;df3c  21 0e 00    ;yes, check extra extent byte 's2' also.
    ADD HL,DE                           ;df3f  19          
    LD  A,B                             ;df40  78          
    SUB (HL)                            ;df41  96          
    AND 7FH                             ;df42  e6 7f       
    JP  Z,POSITN3                       ;df44  ca 7f df    ;same, we are almost done then.
                  ;
                  ;  Get here when another extent is required.
                  ;
POSITN2:PUSH    BC                      ;df47  c5          
    PUSH    DE                          ;df48  d5          
    CALL    CLOSEIT                     ;df49  cd a2 dc    ;close current extent.
    POP DE                              ;df4c  d1          
    POP BC                              ;df4d  c1          
    LD  L,3                             ;df4e  2e 03       ;prepare for error.
    LD  A,(STATUS)                      ;df50  3a 45 d7    
    INC A                               ;df53  3c          
    JP  Z,POSITN4                       ;df54  ca 84 df    ;close error.
    LD  HL,12                           ;df57  21 0c 00    ;put desired extent into fcb now.
    ADD HL,DE                           ;df5a  19          
    LD  (HL),C                          ;df5b  71          
    LD  HL,14                           ;df5c  21 0e 00    ;and store extra extent byte 's2'.
    ADD HL,DE                           ;df5f  19          
    LD  (HL),B                          ;df60  70          
    CALL    OPENIT                      ;df61  cd 51 dc    ;try and get this extent.
    LD  A,(STATUS)                      ;df64  3a 45 d7    ;was it there?
    INC A                               ;df67  3c          
    JP  NZ,POSITN3                      ;df68  c2 7f df    
    POP BC                              ;df6b  c1          ;no. can we create a new one (writing?).
    PUSH    BC                          ;df6c  c5          
    LD  L,4                             ;df6d  2e 04       ;prepare for error.
    INC C                               ;df6f  0c          
    JP  Z,POSITN4                       ;df70  ca 84 df    ;nope, reading unwritten space error.
    CALL    GETEMPTY                    ;df73  cd 24 dd    ;yes we can, try to find space.
    LD  L,5                             ;df76  2e 05       ;prepare for error.
    LD  A,(STATUS)                      ;df78  3a 45 d7    
    INC A                               ;df7b  3c          
    JP  Z,POSITN4                       ;df7c  ca 84 df    ;out of space?
                  ;
                  ;   Normal return location. Clear error code and return.
                  ;
POSITN3:POP BC                          ;df7f  c1          ;restore stack.
    XOR A                               ;df80  af          ;and clear error code byte.
    JP  SETSTAT                         ;df81  c3 01 d7    
                  ;
                  ;   Error. Set the 's2' byte to indicate this (why?).
                  ;
POSITN4:PUSH    HL                      ;df84  e5          
    CALL    GETS2                       ;df85  cd 69 d9    
    LD  (HL),0C0H                       ;df88  36 c0       
    POP HL                              ;df8a  e1          
                  ;
                  ;   Return with error code (presently in L).
                  ;
POSITN5:POP BC                          ;df8b  c1          
    LD  A,L                             ;df8c  7d          ;get error code.
    LD  (STATUS),A                      ;df8d  32 45 d7    
    JP  SETS2B7                         ;df90  c3 78 d9    
                  ;
                  ;   Read a random record.
                  ;
READRAN:LD  C,0FFH                      ;df93  0e ff       ;set 'read' status.
    CALL    POSITION                    ;df95  cd 03 df    ;position the file to proper record.
    CALL    Z,RDSEQ1                    ;df98  cc c1 dd    ;and read it as usual (if no errors).
    RET                                 ;df9b  c9          
                  ;
                  ;   Write to a random record.
                  ;
WRITERAN: LD    C,0                     ;df9c  0e 00       ;set 'writing' flag.
    CALL    POSITION                    ;df9e  cd 03 df    ;position the file to proper record.
    CALL    Z,WTSEQ1                    ;dfa1  cc 03 de    ;and write as usual (if no errors).
    RET                                 ;dfa4  c9          
                  ;
                  ;   Compute the random record number. Enter with (HL) pointing
                  ; to a fcb an (DE) contains a relative location of a record
                  ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
                  ; byte, and (A) the 'r2' byte.
                  ;
                  ;   On return, the zero flag is set if the record is within
                  ; bounds. Otherwise, an overflow occured.
                  ;
COMPRAND: EX    DE,HL                   ;dfa5  eb          ;save fcb pointer in (DE).
    ADD HL,DE                           ;dfa6  19          ;compute relative position of record #.
    LD  C,(HL)                          ;dfa7  4e          ;get record number into (BC).
    LD  B,0                             ;dfa8  06 00       
    LD  HL,12                           ;dfaa  21 0c 00    ;now get extent.
    ADD HL,DE                           ;dfad  19          
    LD  A,(HL)                          ;dfae  7e          ;compute (BC)=(record #)+(extent)*128.
    RRCA                                ;dfaf  0f          ;move lower bit into bit 7.
    AND 80H                             ;dfb0  e6 80       ;and ignore all other bits.
    ADD A,C                             ;dfb2  81          ;add to our record number.
    LD  C,A                             ;dfb3  4f          
    LD  A,0                             ;dfb4  3e 00       ;take care of any carry.
    ADC A,B                             ;dfb6  88          
    LD  B,A                             ;dfb7  47          
    LD  A,(HL)                          ;dfb8  7e          ;now get the upper bits of extent into
    RRCA                                ;dfb9  0f          ;bit positions 0-3.
    AND 0FH                             ;dfba  e6 0f       ;and ignore all others.
    ADD A,B                             ;dfbc  80          ;add this in to 'r1' byte.
    LD  B,A                             ;dfbd  47          
    LD  HL,14                           ;dfbe  21 0e 00    ;get the 's2' byte (extra extent).
    ADD HL,DE                           ;dfc1  19          
    LD  A,(HL)                          ;dfc2  7e          
    ADD A,A                             ;dfc3  87          ;and shift it left 4 bits (bits 4-7).
    ADD A,A                             ;dfc4  87          
    ADD A,A                             ;dfc5  87          
    ADD A,A                             ;dfc6  87          
    PUSH    AF                          ;dfc7  f5          ;save carry flag (bit 0 of flag byte).
    ADD A,B                             ;dfc8  80          ;now add extra extent into 'r1'.
    LD  B,A                             ;dfc9  47          
    PUSH    AF                          ;dfca  f5          ;and save carry (overflow byte 'r2').
    POP HL                              ;dfcb  e1          ;bit 0 of (L) is the overflow indicator.
    LD  A,L                             ;dfcc  7d          
    POP HL                              ;dfcd  e1          ;and same for first carry flag.
    OR  L                               ;dfce  b5          ;either one of these set?
    AND 01H                             ;dfcf  e6 01       ;only check the carry flags.
    RET                                 ;dfd1  c9          
                  ;
                  ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
                  ; reflect the last record used for a random (or other) file.
                  ; This reads the directory and looks at all extents computing
                  ; the largerst record number for each and keeping the maximum
                  ; value only. Then 'r0', 'r1', and 'r2' will reflect this
                  ; maximum record number. This is used to compute the space used
                  ; by a random file.
                  ;
RANSIZE:LD  C,12                        ;dfd2  0e 0c       ;look thru directory for first entry with
    CALL    FINDFST                     ;dfd4  cd 18 db    ;this name.
    LD  HL,(PARAMS)                     ;dfd7  2a 43 d7    ;zero out the 'r0, r1, r2' bytes.
    LD  DE,33                           ;dfda  11 21 00    
    ADD HL,DE                           ;dfdd  19          
    PUSH    HL                          ;dfde  e5          
    LD  (HL),D                          ;dfdf  72          ;note that (D)=0.
    INC HL                              ;dfe0  23          
    LD  (HL),D                          ;dfe1  72          
    INC HL                              ;dfe2  23          
    LD  (HL),D                          ;dfe3  72          
RANSIZ1:CALL    CKFILPOS                ;dfe4  cd f5 d9    ;is there an extent to process?
    JP  Z,RANSIZ3                       ;dfe7  ca 0c e0    ;no, we are done.
    CALL    FCB2HL                      ;dfea  cd 5e d9    ;set (HL) pointing to proper fcb in dir.
    LD  DE,15                           ;dfed  11 0f 00    ;point to last record in extent.
    CALL    COMPRAND                    ;dff0  cd a5 df    ;and compute random parameters.
    POP HL                              ;dff3  e1          
    PUSH    HL                          ;dff4  e5          ;now check these values against those
    LD  E,A                             ;dff5  5f          ;already in fcb.
    LD  A,C                             ;dff6  79          ;the carry flag will be set if those
    SUB (HL)                            ;dff7  96          ;in the fcb represent a larger size than
    INC HL                              ;dff8  23          ;this extent does.
    LD  A,B                             ;dff9  78          
    SBC A,(HL)                          ;dffa  9e          
    INC HL                              ;dffb  23          
    LD  A,E                             ;dffc  7b          
    SBC A,(HL)                          ;dffd  9e          
    JP  C,RANSIZ2                       ;dffe  da 06 e0    
    LD  (HL),E                          ;e001  73          ;we found a larger (in size) extent.
    DEC HL                              ;e002  2b          ;stuff these values into fcb.
    LD  (HL),B                          ;e003  70          
    DEC HL                              ;e004  2b          
    LD  (HL),C                          ;e005  71          
RANSIZ2:CALL    FINDNXT                 ;e006  cd 2d db    ;now get the next extent.
    JP  RANSIZ1                         ;e009  c3 e4 df    ;continue til all done.
RANSIZ3:POP HL                          ;e00c  e1          ;we are done, restore the stack and
    RET                                 ;e00d  c9          ;return.
                  ;
                  ;   Function to return the random record position of a given
                  ; file which has been read in sequential mode up to now.
                  ;
SETRAN: LD  HL,(PARAMS)                 ;e00e  2a 43 d7    ;point to fcb.
    LD  DE,32                           ;e011  11 20 00    ;and to last used record.
    CALL    COMPRAND                    ;e014  cd a5 df    ;compute random position.
    LD  HL,33                           ;e017  21 21 00    ;now stuff these values into fcb.
    ADD HL,DE                           ;e01a  19          
    LD  (HL),C                          ;e01b  71          ;move 'r0'.
    INC HL                              ;e01c  23          
    LD  (HL),B                          ;e01d  70          ;and 'r1'.
    INC HL                              ;e01e  23          
    LD  (HL),A                          ;e01f  77          ;and lastly 'r2'.
    RET                                 ;e020  c9          
                  ;
                  ;   This routine select the drive specified in (ACTIVE) and
                  ; update the login vector and bitmap table if this drive was
                  ; not already active.
                  ;
LOGINDRV: LD    HL,(LOGIN)              ;e021  2a af e1    ;get the login vector.
    LD  A,(ACTIVE)                      ;e024  3a 42 d7    ;get the default drive.
    LD  C,A                             ;e027  4f          
    CALL    SHIFTR                      ;e028  cd ea d8    ;position active bit for this drive
    PUSH    HL                          ;e02b  e5          ;into bit 0.
    EX  DE,HL                           ;e02c  eb          
    CALL    SELECT                      ;e02d  cd 59 d7    ;select this drive.
    POP HL                              ;e030  e1          
    CALL    Z,SLCTERR                   ;e031  cc 47 d7    ;valid drive?
    LD  A,L                             ;e034  7d          ;is this a newly activated drive?
    RRA                                 ;e035  1f          
    RET C                               ;e036  d8          
    LD  HL,(LOGIN)                      ;e037  2a af e1    ;yes, update the login vector.
    LD  C,L                             ;e03a  4d          
    LD  B,H                             ;e03b  44          
    CALL    SETBIT                      ;e03c  cd 0b d9    
    LD  (LOGIN),HL                      ;e03f  22 af e1    ;and save.
    JP  BITMAP                          ;e042  c3 a3 da    ;now update the bitmap.
                  ;
                  ;   Function to set the active disk number.
                  ;
SETDSK: LD  A,(EPARAM)                  ;e045  3a d6 e1    ;get parameter passed and see if this
    LD  HL,ACTIVE                       ;e048  21 42 d7    ;represents a change in drives.
    CP  (HL)                            ;e04b  be          
    RET Z                               ;e04c  c8          
    LD  (HL),A                          ;e04d  77          ;yes it does, log it in.
    JP  LOGINDRV                        ;e04e  c3 21 e0    
                  ;
                  ;   This is the 'auto disk select' routine. The firsst byte
                  ; of the fcb is examined for a drive specification. If non
                  ; zero then the drive will be selected and loged in.
                  ;
AUTOSEL:LD  A,0FFH                      ;e051  3e ff       ;say 'auto-select activated'.
    LD  (AUTO),A                        ;e053  32 de e1    
    LD  HL,(PARAMS)                     ;e056  2a 43 d7    ;get drive specified.
    LD  A,(HL)                          ;e059  7e          
    AND 1FH                             ;e05a  e6 1f       ;look at lower 5 bits.
    DEC A                               ;e05c  3d          ;adjust for (1=A, 2=B) etc.
    LD  (EPARAM),A                      ;e05d  32 d6 e1    ;and save for the select routine.
    CP  1EH                             ;e060  fe 1e       ;check for 'no change' condition.
    JP  NC,AUTOSL1                      ;e062  d2 75 e0    ;yes, don't change.
    LD  A,(ACTIVE)                      ;e065  3a 42 d7    ;we must change, save currently active
    LD  (OLDDRV),A                      ;e068  32 df e1    ;drive.
    LD  A,(HL)                          ;e06b  7e          ;and save first byte of fcb also.
    LD  (AUTOFLAG),A                    ;e06c  32 e0 e1    ;this must be non-zero.
    AND 0E0H                            ;e06f  e6 e0       ;whats this for (bits 6,7 are used for
    LD  (HL),A                          ;e071  77          ;something)?
    CALL    SETDSK                      ;e072  cd 45 e0    ;select and log in this drive.
AUTOSL1:LD  A,(USERNO)                  ;e075  3a 41 d7    ;move user number into fcb.
    LD  HL,(PARAMS)                     ;e078  2a 43 d7    ;(* upper half of first byte *)
    OR  (HL)                            ;e07b  b6          
    LD  (HL),A                          ;e07c  77          
    RET                                 ;e07d  c9          ;and return (all done).
                  ;
                  ;   Function to return the current cp/m version number.
                  ;
GETVER: LD  A,022H                      ;e07e  3e 22       ;version 2.2
    JP  SETSTAT                         ;e080  c3 01 d7    
                  ;
                  ;   Function to reset the disk system.
                  ;
RSTDSK: LD  HL,0                        ;e083  21 00 00    ;clear write protect status and log
    LD  (WRTPRT),HL                     ;e086  22 ad e1    ;in vector.
    LD  (LOGIN),HL                      ;e089  22 af e1    
    XOR A                               ;e08c  af          ;select drive 'A'.
    LD  (ACTIVE),A                      ;e08d  32 42 d7    
    LD  HL,TBUFF                        ;e090  21 80 00    ;setup default dma address.
    LD  (USERDMA),HL                    ;e093  22 b1 e1    
    CALL    DEFDMA                      ;e096  cd da d9    
    JP  LOGINDRV                        ;e099  c3 21 e0    ;now log in drive 'A'.
                  ;
                  ;   Function to open a specified file.
                  ;
OPENFIL:CALL    CLEARS2                 ;e09c  cd 72 d9    ;clear 's2' byte.
    CALL    AUTOSEL                     ;e09f  cd 51 e0    ;select proper disk.
    JP  OPENIT                          ;e0a2  c3 51 dc    ;and open the file.
                  ;
                  ;   Function to close a specified file.
                  ;
CLOSEFIL: CALL  AUTOSEL                 ;e0a5  cd 51 e0    ;select proper disk.
    JP  CLOSEIT                         ;e0a8  c3 a2 dc    ;and close the file.
                  ;
                  ;   Function to return the first occurence of a specified file
                  ; name. If the first byte of the fcb is '?' then the name will
                  ; not be checked (get the first entry no matter what).
                  ;
GETFST: LD  C,0                         ;e0ab  0e 00       ;prepare for special search.
    EX  DE,HL                           ;e0ad  eb          
    LD  A,(HL)                          ;e0ae  7e          ;is first byte a '?'?
    CP  '?'                             ;e0af  fe 3f       
    JP  Z,GETFST1                       ;e0b1  ca c2 e0    ;yes, just get very first entry (zero length match).
    CALL    SETEXT                      ;e0b4  cd a6 d8    ;get the extension byte from fcb.
    LD  A,(HL)                          ;e0b7  7e          ;is it '?'? if yes, then we want
    CP  '?'                             ;e0b8  fe 3f       ;an entry with a specific 's2' byte.
    CALL    NZ,CLEARS2                  ;e0ba  c4 72 d9    ;otherwise, look for a zero 's2' byte.
    CALL    AUTOSEL                     ;e0bd  cd 51 e0    ;select proper drive.
    LD  C,15                            ;e0c0  0e 0f       ;compare bytes 0-14 in fcb (12&13 excluded).
GETFST1:CALL    FINDFST                 ;e0c2  cd 18 db    ;find an entry and then move it into
    JP  MOVEDIR                         ;e0c5  c3 e9 d9    ;the users dma space.
                  ;
                  ;   Function to return the next occurence of a file name.
                  ;
GETNXT: LD  HL,(SAVEFCB)                ;e0c8  2a d9 e1    ;restore pointers. note that no
    LD  (PARAMS),HL                     ;e0cb  22 43 d7    ;other dbos calls are allowed.
    CALL    AUTOSEL                     ;e0ce  cd 51 e0    ;no error will be returned, but the
    CALL    FINDNXT                     ;e0d1  cd 2d db    ;results will be wrong.
    JP  MOVEDIR                         ;e0d4  c3 e9 d9    
                  ;
                  ;   Function to delete a file by name.
                  ;
DELFILE:CALL    AUTOSEL                 ;e0d7  cd 51 e0    ;select proper drive.
    CALL    ERAFILE                     ;e0da  cd 9c db    ;erase the file.
    JP  STSTATUS                        ;e0dd  c3 01 db    ;set status and return.
                  ;
                  ;   Function to execute a sequential read of the specified
                  ; record number.
                  ;
READSEQ:CALL    AUTOSEL                 ;e0e0  cd 51 e0    ;select proper drive then read.
    JP  RDSEQ                           ;e0e3  c3 bc dd    
                  ;
                  ;   Function to write the net sequential record.
                  ;
WRTSEQ: CALL    AUTOSEL                 ;e0e6  cd 51 e0    ;select proper drive then write.
    JP  WTSEQ                           ;e0e9  c3 fe dd    
                  ;
                  ;   Create a file function.
                  ;
FCREATE:CALL    CLEARS2                 ;e0ec  cd 72 d9    ;clear the 's2' byte on all creates.
    CALL    AUTOSEL                     ;e0ef  cd 51 e0    ;select proper drive and get the next
    JP  GETEMPTY                        ;e0f2  c3 24 dd    ;empty directory space.
                  ;
                  ;   Function to rename a file.
                  ;
RENFILE:CALL    AUTOSEL                 ;e0f5  cd 51 e0    ;select proper drive and then switch
    CALL    CHGNAMES                    ;e0f8  cd 16 dc    ;file names.
    JP  STSTATUS                        ;e0fb  c3 01 db    
                  ;
                  ;   Function to return the login vector.
                  ;
GETLOG: LD  HL,(LOGIN)                  ;e0fe  2a af e1    
    JP  GETPRM1                         ;e101  c3 29 e1    
                  ;
                  ;   Function to return the current disk assignment.
                  ;
GETCRNT:LD  A,(ACTIVE)                  ;e104  3a 42 d7    
    JP  SETSTAT                         ;e107  c3 01 d7    
                  ;
                  ;   Function to set the dma address.
                  ;
PUTDMA: EX  DE,HL                       ;e10a  eb          
    LD  (USERDMA),HL                    ;e10b  22 b1 e1    ;save in our space and then get to
    JP  DEFDMA                          ;e10e  c3 da d9    ;the bios with this also.
                  ;
                  ;   Function to return the allocation vector.
                  ;
GETALOC:LD  HL,(ALOCVECT)               ;e111  2a bf e1    
    JP  GETPRM1                         ;e114  c3 29 e1    
                  ;
                  ;   Function to return the read-only status vector.
                  ;
GETROV: LD  HL,(WRTPRT)                 ;e117  2a ad e1    
    JP  GETPRM1                         ;e11a  c3 29 e1    
                  ;
                  ;   Function to set the file attributes (read-only, system).
                  ;
SETATTR:CALL    AUTOSEL                 ;e11d  cd 51 e0    ;select proper drive then save attributes.
    CALL    SAVEATTR                    ;e120  cd 3b dc    
    JP  STSTATUS                        ;e123  c3 01 db    
                  ;
                  ;   Function to return the address of the disk parameter block
                  ; for the current drive.
                  ;
GETPARM:LD  HL,(DISKPB)                 ;e126  2a bb e1    
GETPRM1:LD  (STATUS),HL                 ;e129  22 45 d7    
    RET                                 ;e12c  c9          
                  ;
                  ;   Function to get or set the user number. If (E) was (FF)
                  ; then this is a request to return the current user number.
                  ; Else set the user number from (E).
                  ;
GETUSER:LD  A,(EPARAM)                  ;e12d  3a d6 e1    ;get parameter.
    CP  0FFH                            ;e130  fe ff       ;get user number?
    JP  NZ,SETUSER                      ;e132  c2 3b e1    
    LD  A,(USERNO)                      ;e135  3a 41 d7    ;yes, just do it.
    JP  SETSTAT                         ;e138  c3 01 d7    
SETUSER:AND 1FH                         ;e13b  e6 1f       ;no, we should set it instead. keep low
    LD  (USERNO),A                      ;e13d  32 41 d7    ;bits (0-4) only.
    RET                                 ;e140  c9          
                  ;
                  ;   Function to read a random record from a file.
                  ;
RDRANDOM: CALL  AUTOSEL                 ;e141  cd 51 e0    ;select proper drive and read.
    JP  READRAN                         ;e144  c3 93 df    
                  ;
                  ;   Function to compute the file size for random files.
                  ;
WTRANDOM: CALL  AUTOSEL                 ;e147  cd 51 e0    ;select proper drive and write.
    JP  WRITERAN                        ;e14a  c3 9c df    
                  ;
                  ;   Function to compute the size of a random file.
                  ;
FILESIZE: CALL  AUTOSEL                 ;e14d  cd 51 e0    ;select proper drive and check file length
    JP  RANSIZE                         ;e150  c3 d2 df    
                  ;
                  ;   Function #37. This allows a program to log off any drives.
                  ; On entry, set (DE) to contain a word with bits set for those
                  ; drives that are to be logged off. The log-in vector and the
                  ; write protect vector will be updated. This must be a M/PM
                  ; special function.
                  ;
LOGOFF: LD  HL,(PARAMS)                 ;e153  2a 43 d7    ;get drives to log off.
    LD  A,L                             ;e156  7d          ;for each bit that is set, we want
    CPL                                 ;e157  2f          ;to clear that bit in (LOGIN)
    LD  E,A                             ;e158  5f          ;and (WRTPRT).
    LD  A,H                             ;e159  7c          
    CPL                                 ;e15a  2f          
    LD  HL,(LOGIN)                      ;e15b  2a af e1    ;reset the login vector.
    AND H                               ;e15e  a4          
    LD  D,A                             ;e15f  57          
    LD  A,L                             ;e160  7d          
    AND E                               ;e161  a3          
    LD  E,A                             ;e162  5f          
    LD  HL,(WRTPRT)                     ;e163  2a ad e1    
    EX  DE,HL                           ;e166  eb          
    LD  (LOGIN),HL                      ;e167  22 af e1    ;and save.
    LD  A,L                             ;e16a  7d          ;now do the write protect vector.
    AND E                               ;e16b  a3          
    LD  L,A                             ;e16c  6f          
    LD  A,H                             ;e16d  7c          
    AND D                               ;e16e  a2          
    LD  H,A                             ;e16f  67          
    LD  (WRTPRT),HL                     ;e170  22 ad e1    ;and save. all done.
    RET                                 ;e173  c9          
                  ;
                  ;   Get here to return to the user.
                  ;
GOBACK: LD  A,(AUTO)                    ;e174  3a de e1    ;was auto select activated?
    OR  A                               ;e177  b7          
    JP  Z,GOBACK1                       ;e178  ca 91 e1    
    LD  HL,(PARAMS)                     ;e17b  2a 43 d7    ;yes, but was a change made?
    LD  (HL),0                          ;e17e  36 00       ;(* reset first byte of fcb *)
    LD  A,(AUTOFLAG)                    ;e180  3a e0 e1    
    OR  A                               ;e183  b7          
    JP  Z,GOBACK1                       ;e184  ca 91 e1    
    LD  (HL),A                          ;e187  77          ;yes, reset first byte properly.
    LD  A,(OLDDRV)                      ;e188  3a df e1    ;and get the old drive and select it.
    LD  (EPARAM),A                      ;e18b  32 d6 e1    
    CALL    SETDSK                      ;e18e  cd 45 e0    
GOBACK1:LD  HL,(USRSTACK)               ;e191  2a 0f d7    ;reset the users stack pointer.
    LD  SP,HL                           ;e194  f9          
    LD  HL,(STATUS)                     ;e195  2a 45 d7    ;get return status.
    LD  A,L                             ;e198  7d          ;force version 1.4 compatability.
    LD  B,H                             ;e199  44          
    RET                                 ;e19a  c9          ;and go back to user.
                  ;
                  ;   Function #40. This is a special entry to do random i/o.
                  ; For the case where we are writing to unused disk space, this
                  ; space will be zeroed out first. This must be a M/PM special
                  ; purpose function, because why would any normal program even
                  ; care about the previous contents of a sector about to be
                  ; written over.
                  ;
WTSPECL:CALL    AUTOSEL                 ;e19b  cd 51 e0    ;select proper drive.
    LD  A,2                             ;e19e  3e 02       ;use special write mode.
    LD  (MODE),A                        ;e1a0  32 d5 e1    
    LD  C,0                             ;e1a3  0e 00       ;set write indicator.
    CALL    POSITN1                     ;e1a5  cd 07 df    ;position the file.
    CALL    Z,WTSEQ1                    ;e1a8  cc 03 de    ;and write (if no errors).
    RET                                 ;e1ab  c9          
                  ;
                  ;**************************************************************
                  ;*
                  ;*     BDOS data storage pool.
                  ;*
                  ;**************************************************************
                  ;
EMPTYFCB: DEFB  0E5H                    ;e1ac  e5          ;empty directory segment indicator.
WRTPRT: DEFW    0                       ;e1ad  00 00       ;write protect status for all 16 drives.
LOGIN:  DEFW    0                       ;e1af  00 00       ;drive active word (1 bit per drive).
USERDMA:DEFW    080H                    ;e1b1  80 00       ;user's dma address (defaults to 80h).
                  ;
                  ;   Scratch areas from parameter block.
                  ;
SCRATCH1: DEFW  0                       ;e1b3  00 00       ;relative position within dir segment for file (0-3).
SCRATCH2: DEFW  0                       ;e1b5  00 00       ;last selected track number.
SCRATCH3: DEFW  0                       ;e1b7  00 00       ;last selected sector number.
                  ;
                  ;   Disk storage areas from parameter block.
                  ;
DIRBUF: DEFW    0                       ;e1b9  00 00       ;address of directory buffer to use.
DISKPB: DEFW    0                       ;e1bb  00 00       ;contains address of disk parameter block.
CHKVECT:DEFW    0                       ;e1bd  00 00       ;address of check vector.
ALOCVECT: DEFW  0                       ;e1bf  00 00       ;address of allocation vector (bit map).
                  ;
                  ;   Parameter block returned from the bios.
                  ;
SECTORS:DEFW    0                       ;e1c1  00 00       ;sectors per track from bios.
BLKSHFT:DEFB    0                       ;e1c3  00          ;block shift.
BLKMASK:DEFB    0                       ;e1c4  00          ;block mask.
EXTMASK:DEFB    0                       ;e1c5  00          ;extent mask.
DSKSIZE:DEFW    0                       ;e1c6  00 00       ;disk size from bios (number of blocks-1).
DIRSIZE:DEFW    0                       ;e1c8  00 00       ;directory size.
ALLOC0: DEFW    0                       ;e1ca  00 00       ;storage for first bytes of bit map (dir space used).
ALLOC1: DEFW    0                       ;e1cc  00 00       
OFFSET: DEFW    0                       ;e1ce  00 00       ;first usable track number.
XLATE:  DEFW    0                       ;e1d0  00 00       ;sector translation table address.
                  ;
                  ;
CLOSEFLG: DEFB  0                       ;e1d2  00          ;close flag (=0ffh is extent written ok).
RDWRTFLG: DEFB  0                       ;e1d3  00          ;read/write flag (0ffh=read, 0=write).
FNDSTAT:DEFB    0                       ;e1d4  00          ;filename found status (0=found first entry).
MODE:   DEFB    0                       ;e1d5  00          ;I/o mode select (0=random, 1=sequential, 2=special random).
EPARAM: DEFB    0                       ;e1d6  00          ;storage for register (E) on entry to bdos.
RELBLOCK: DEFB  0                       ;e1d7  00          ;relative position within fcb of block number written.
COUNTER:DEFB    0                       ;e1d8  00          ;byte counter for directory name searches.
SAVEFCB:DEFW    0,0                     ;e1d9  00 00 00 00 ;save space for address of fcb (for directory searches).
BIGDISK:DEFB    0                       ;e1dd  00          ;if =0 then disk is > 256 blocks long.
AUTO:   DEFB    0                       ;e1de  00          ;if non-zero, then auto select activated.
OLDDRV: DEFB    0                       ;e1df  00          ;on auto select, storage for previous drive.
AUTOFLAG: DEFB  0                       ;e1e0  00          ;if non-zero, then auto select changed drives.
SAVNXT: DEFB    0                       ;e1e1  00          ;storage for next record number to access.
SAVEXT: DEFB    0                       ;e1e2  00          ;storage for extent number of file.
SAVNREC:DEFW    0                       ;e1e3  00 00       ;storage for number of records in file.
BLKNMBR:DEFW    0                       ;e1e5  00 00       ;block number (physical sector) used within a file or logical sect
LOGSECT:DEFW    0                       ;e1e7  00 00       ;starting logical (128 byte) sector of block (physical sector).
FCBPOS: DEFB    0                       ;e1e9  00          ;relative position within buffer for fcb of file of interest.
FILEPOS:DEFW    0                       ;e1ea  00 00       ;files position within directory (0 to max entries -1).
                  ;
                  ;   Disk directory buffer checksum bytes. One for each of the
                  ; 16 possible drives.
                  ;
CKSUMTBL: DEFB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;e1ec  00 00 00 00 
                                        ;e1f0  00 00 00 00   3705   3802
                                        ;e1f4  00 00 00 00   3705   3803
                                        ;e1f8  00 00 00 00   3705   3804
                  ;
                  ;   Extra space ?
                  ;
    DEFB    0,0,0,0                     ;e1fc  00 00 00 00 
                  ;
                  ;**************************************************************
                  ;*
                  ;*        B I O S   J U M P   T A B L E
                  ;*
                  ;**************************************************************
                  ;
BOOT:   JP  0                           ;e200  c3 00 00    ;NOTE WE USE FAKE DESTINATIONS
WBOOT:  JP  0                           ;e203  c3 00 00    
CONST:  JP  0                           ;e206  c3 00 00    
CONIN:  JP  0                           ;e209  c3 00 00    
CONOUT: JP  0                           ;e20c  c3 00 00    
LIST:   JP  0                           ;e20f  c3 00 00    
PUNCH:  JP  0                           ;e212  c3 00 00    
READER: JP  0                           ;e215  c3 00 00    
HOME:   JP  0                           ;e218  c3 00 00    
SELDSK: JP  0                           ;e21b  c3 00 00    
SETTRK: JP  0                           ;e21e  c3 00 00    
SETSEC: JP  0                           ;e221  c3 00 00    
SETDMA: JP  0                           ;e224  c3 00 00    
READ:   JP  0                           ;e227  c3 00 00    
WRITE:  JP  0                           ;e22a  c3 00 00    
PRSTAT: JP  0                           ;e22d  c3 00 00    
SECTRN: JP  0                           ;e230  c3 00 00    
                  ;
                  ;*
                  ;******************   E N D   O F   C P / M   *****************
                  ;*
                  
;Z80-Assembler		Release 1.6				Page 1
;Source file: spc-1000_cpm22.asm
;Title:       Symboltable

IOBYTE   0003	CNTRLC   0003	TDRIVE   0004	CNTRLE   0005	
ENTRY    0005	NUMCMDS  0006	BS       0008	TAB      0009	
LF       000a	FF       000c	CR       000d	CNTRLP   0010	
CNTRLR   0012	CNTRLS   0013	CNTRLU   0015	CNTRLX   0018	
CNTRLZ   001a	NFUNCTS  0029	MEM      003a	TFCB     005c	
DEL      007f	TBUFF    0080	TBASE    0100	CBASE    cc00	
INBUFF   cc06	INPOINT  cc88	NAMEPNT  cc8a	PRINT    cc8c	
PRINTB   cc92	CRLF     cc98	SPACE    cca2	PLINE    cca7	
PLINE2   ccac	RESDSK   ccb8	DSKSEL   ccbd	ENTRY1   ccc3	
OPEN     cccb	OPENFCB  ccd0	CLOSE    ccda	SRCHFST  ccdf	
SRCHNXT  cce4	SRCHFCB  cce9	DELETE   ccef	ENTRY2   ccf4	
RDREC    ccf9	READFCB  ccfe	WRTREC   cd04	CREATE   cd09	
RENAM    cd0e	GETUSR   cd13	GETSETUC cd15	SETCDRV  cd1a	
MOVECD   cd29	UPPER    cd30	GETINP   cd39	GETINP1  cd96	
GETINP2  cda7	GETINP3  cdab	GETINP4  cdba	CHKCON   cdc2	
GETDSK   cdd0	STDDMA   cdd5	DMASET   cdd8	DELBATCH cddd	
VERIFY   cdf5	VERIFY1  cdfd	SYNERR   ce09	SYNERR1  ce0f	
SYNERR2  ce22	CHECK    ce30	NONBLANK ce4f	ADDHL    ce59	
CONVFST  ce5e	CONVERT  ce60	CONVRT1  ce89	CONVRT2  ce90	
CONVRT3  ce96	CONVRT4  ce98	CONVRT5  cea9	CONVRT6  ceab	
CONVRT7  ceaf	CONVRT8  ceb9	GETEXT   cec0	GETEXT1  cec8	
GETEXT2  ced9	GETEXT3  cedb	GETEXT4  cedf	GETEXT5  cee9	
GETEXT6  cef0	GETEXT7  cef2	GETEXT8  cf01	GETEXT9  cf09	
CMDTBL   cf10	PATTRN1  cf28	SEARCH   cf2e	SEARCH1  cf33	
SEARCH2  cf3c	SEARCH3  cf4f	SEARCH4  cf54	CLEARBUF cf58	
COMMAND  cf5c	CMMND1   cf82	CMMND2   cf98	CMDADR   cfc1	
HALT     cfcf	RDERROR  cfd9	RDERR    cfdf	NONE     cfea	
NOFILE   cff0	DECODE   cff8	DECODE1  d008	DECODE2  d02a	
DECODE3  d033	DECODE4  d03a	MOVE3    d040	HL2DE    d042	
EXTRACT  d04b	DSELECT  d054	RESETDR  d066	DIRECT   d077	
DIRECT1  d088	DIRECT2  d08f	DIRECT3  d098	DIRECT4  d0cc	
DIRECT5  d0d4	DIRECT6  d0d9	DRECT63  d0f7	DRECT65  d0f9	
DIRECT7  d10e	DIRECT8  d10f	DIRECT9  d11b	ERASE    d11f	
ERASE1   d142	YESNO    d152	TYPE     d15d	TYPE1    d174	
TYPE2    d177	TYPE3    d187	TYPE4    d1a0	TYPE5    d1a7	
SAVE     d1ad	SAVE1    d1d4	SAVE2    d1f1	SAVE3    d1fb	
SAVE4    d201	NOSPACE  d207	RENAME   d210	RENAME1  d23f	
RENAME2  d259	RENAME3  d25e	RENAME4  d26d	RENAME5  d273	
RENAME6  d279	EXISTS   d282	USER     d28e	UNKNOWN  d2a5	
UNKWN1   d2c4	UNKWN2   d2cd	UNKWN3   d2e1	UNKWN4   d301	
UNKWN5   d330	UNKWN6   d33e	UNKWN7   d343	UNKWN8   d34f	
UNKWN9   d36b	UNKWN0   d371	BADLOAD  d37a	COMFILE  d383	
GETBACK  d386	GETBACK1 d389	BATCH    d3ab	CCPSTACK d3ab	
BATCHFCB d3ac	FCB      d3cd	RTNCODE  d3ee	CDRIVE   d3ef	
CHGDRV   d3f0	NBYTES   d3f1	PATTRN2  d400	FBASE    d406	
BADSCTR  d409	BADSLCT  d40b	RODISK   d40d	ROFILE   d40f	
FBASE1   d411	FUNCTNS  d447	ERROR1   d499	ERROR2   d4a5	
ERROR3   d4ab	ERROR4   d4b1	ERROR5   d4b4	BDOSERR  d4ba	
BDOSDRV  d4c6	BADSEC   d4ca	BADSEL   d4d5	FILERO   d4dc	
DISKRO   d4e1	PRTERR   d4e5	GETCHAR  d4fb	GETECHO  d506	
CHKCHAR  d514	CKCONSOL d523	CKCON1   d542	CKCON2   d545	
OUTCHAR  d548	OUTCHR1  d562	OUTCHR2  d579	SHOWIT   d57f	
OUTCON   d590	OUTCON1  d596	BACKUP   d5a4	BACKUP1  d5ac	
NEWLINE  d5b1	NEWLN1   d5b9	OUTCRLF  d5c9	PRTMESG  d5d3	
RDBUFF   d5e1	RDBUF1   d5ef	RDBUF2   d5f1	RDBUF3   d616	
RDBUF4   d626	RDBUF5   d637	RDBUF6   d648	RDBUF7   d64e	
RDBUF8   d65f	RDBUF9   d66b	RDBUF10  d670	RDBUF11  d678	
RDBUF12  d68a	RDBUF13  d699	RDBUF14  d6a6	RDBUF15  d6a9	
RDBUF16  d6bd	RDBUF17  d6c1	GETCON   d6c8	GETRDR   d6ce	
DIRCIO   d6d4	DIRC1    d6e0	GETIOB   d6ed	SETIOB   d6f3	
PRTSTR   d6f8	GETCSTS  d6fe	SETSTAT  d701	RTN      d704	
IOERR1   d705	OUTFLAG  d70a	STARTING d70b	CURPOS   d70c	
PRTFLAG  d70d	CHARBUF  d70e	USRSTACK d70f	STKAREA  d741	
USERNO   d741	ACTIVE   d742	PARAMS   d743	STATUS   d745	
SLCTERR  d747	JUMPHL   d74a	DE2HL    d74f	DE2HL1   d750	
SELECT   d759	SELECT1  d79d	HOMEDRV  d7a1	DOREAD   d7b2	
DOWRITE  d7b8	IORET    d7bb	TRKSEC   d7c3	TRKSEC1  d7d1	
TRKSEC2  d7e4	TRKSEC3  d7fa	TRKSEC4  d80f	GETBLOCK d83e	
GETBLK1  d845	GETBLK2  d853	GETBLK3  d85c	EXTBLK   d85e	
EXTBLK1  d871	COMBLK   d877	CHKBLK   d884	LOGICAL  d88a	
LOGICL1  d890	SETEXT   d8a6	SETHLDE  d8ae	STRDATA  d8bb	
SETNREC  d8d2	STNREC1  d8de	SHIFTR   d8ea	SHIFTR1  d8eb	
CHECKSUM d8f7	CHKSUM1  d8fd	SHIFTL   d904	SHIFTL1  d905	
SETBIT   d90b	GETWPRT  d91e	WRTPRTD  d92c	CHKROFL  d944	
CKROF1   d947	CHKWPRT  d954	FCB2HL   d95e	ADDA2HL  d964	
GETS2    d969	CLEARS2  d972	SETS2B7  d978	MOREFLS  d97f	
CHKNMBR  d98c	SUBHL    d995	SETDIR   d99c	CHECKDIR d99e	
CHKDIR1  d9c4	DIRWRITE d9c6	DIRREAD  d9d4	DEFDMA   d9da	
DIRDMA   d9e0	DIRDMA1  d9e3	MOVEDIR  d9e9	CKFILPOS d9f5	
STFILPOS d9fe	NXENTRY  da05	NXENT1   da19	NXENT2   da20	
CKBITMAP da35	CKBMAP1  da56	STBITMAP da5c	STBMAP1  da64	
SETFILE  da6b	SETFL1   da75	SETFL2   da88	SETFL3   da8e	
SETFL4   da9d	BITMAP   daa3	BITMAP1  dab1	BITMAP2  dad2	
BITMAP3  daf6	STSTATUS db01	SAMEXT   db07	FINDFST  db18	
FINDNXT  db2d	FNDNXT1  db4a	FNDNXT2  db53	FNDNXT3  db73	
FNDNXT4  db7c	FNDNXT5  db83	FNDNXT6  db94	ERAFILE  db9c	
ERAFIL1  dba4	FNDSPACE dbbe	FNDSPA1  dbc0	FNDSPA2  dbd1	
FNDSPA3  dbec	FNDSPA4  dbf4	FCBSET   dbfd	UPDATE   dc01	
UPDATE1  dc10	CHGNAMES dc16	CHGNAM1  dc27	SAVEATTR dc3b	
SAVATR1  dc40	OPENIT   dc51	OPENIT1  dc5a	OPENIT2  dc8b	
MOVEWORD dc94	CLOSEIT  dca2	CLOSEIT1 dccd	CLOSEIT2 dcdb	
CLOSEIT3 dce1	CLOSEIT4 dce8	CLOSEIT5 dcfd	CLOSEIT6 dd17	
CLOSEIT7 dd1f	GETEMPTY dd24	GETMT1   dd46	GETNEXT  dd5a	
GTNEXT1  dd83	GTNEXT2  dd8e	GTNEXT3  ddac	GTNEXT4  ddaf	
GTNEXT5  ddb6	RDSEQ    ddbc	RDSEQ1   ddc1	RDSEQ2   dde6	
RDSEQ3   ddfb	WTSEQ    ddfe	WTSEQ1   de03	WTSEQ2   de3b	
WTSEQ3   de48	WTSEQ4   de64	WTSEQ5   de6c	WTSEQ6   de6e	
WTSEQ7   de8c	WTSEQ8   de9a	WTSEQ9   debb	WTSEQ10  ded2	
WTSEQ99  dedf	WTSEQ11  defe	WTSEQ12  df00	POSITION df03	
POSITN1  df07	POSITN2  df47	POSITN3  df7f	POSITN4  df84	
POSITN5  df8b	READRAN  df93	WRITERAN df9c	COMPRAND dfa5	
RANSIZE  dfd2	RANSIZ1  dfe4	RANSIZ2  e006	RANSIZ3  e00c	
SETRAN   e00e	LOGINDRV e021	SETDSK   e045	AUTOSEL  e051	
AUTOSL1  e075	GETVER   e07e	RSTDSK   e083	OPENFIL  e09c	
CLOSEFIL e0a5	GETFST   e0ab	GETFST1  e0c2	GETNXT   e0c8	
DELFILE  e0d7	READSEQ  e0e0	WRTSEQ   e0e6	FCREATE  e0ec	
RENFILE  e0f5	GETLOG   e0fe	GETCRNT  e104	PUTDMA   e10a	
GETALOC  e111	GETROV   e117	SETATTR  e11d	GETPARM  e126	
GETPRM1  e129	GETUSER  e12d	SETUSER  e13b	RDRANDOM e141	
WTRANDOM e147	FILESIZE e14d	LOGOFF   e153	GOBACK   e174	
GOBACK1  e191	WTSPECL  e19b	EMPTYFCB e1ac	WRTPRT   e1ad	
LOGIN    e1af	USERDMA  e1b1	SCRATCH1 e1b3	SCRATCH2 e1b5	
SCRATCH3 e1b7	DIRBUF   e1b9	DISKPB   e1bb	CHKVECT  e1bd	
ALOCVECT e1bf	SECTORS  e1c1	BLKSHFT  e1c3	BLKMASK  e1c4	
EXTMASK  e1c5	DSKSIZE  e1c6	DIRSIZE  e1c8	ALLOC0   e1ca	
ALLOC1   e1cc	OFFSET   e1ce	XLATE    e1d0	CLOSEFLG e1d2	
RDWRTFLG e1d3	FNDSTAT  e1d4	MODE     e1d5	EPARAM   e1d6	
RELBLOCK e1d7	COUNTER  e1d8	SAVEFCB  e1d9	BIGDISK  e1dd	
AUTO     e1de	OLDDRV   e1df	AUTOFLAG e1e0	SAVNXT   e1e1	
SAVEXT   e1e2	SAVNREC  e1e3	BLKNMBR  e1e5	LOGSECT  e1e7	
FCBPOS   e1e9	FILEPOS  e1ea	CKSUMTBL e1ec	BOOT     e200	
WBOOT    e203	CONST    e206	CONIN    e209	CONOUT   e20c	
LIST     e20f	PUNCH    e212	READER   e215	HOME     e218	
SELDSK   e21b	SETTRK   e21e	SETSEC   e221	SETDMA   e224	
READ     e227	WRITE    e22a	PRSTAT   e22d	SECTRN   e230	


No undefined symbol.
